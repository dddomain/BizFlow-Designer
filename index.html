<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BizFlow Designer (v7.5 Refactored)</title>
    <style>
        /* =========================================
           CSS Reset & Variables
           ========================================= */
        :root {
            --bg-color: #f0f0f0;
            --panel-bg: #ffffff;
            --border-color: #e2e8f0;
            --text-main: #334155;
            --text-muted: #64748b;
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --grid-color: #cbd5e1;
            --selection-color: #3b82f6;
            --drag-placeholder: #eff6ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Yu Gothic UI', 'Meiryo', sans-serif;
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-color);
            user-select: none;
            touch-action: none;
        }

        /* =========================================
           Layout
           ========================================= */
        .app-container {
            display: grid;
            grid-template-columns: 240px 1fr 280px;
            height: 100%;
            width: 100%;
        }

        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .h-full { height: 100%; }
        .overflow-hidden { overflow: hidden; }
        .items-center { align-items: center; }
        .gap-2 { gap: 0.5rem; }
        .p-4 { padding: 1rem; }
        .border-b { border-bottom: 1px solid var(--border-color); }
        .border-r { border-right: 1px solid var(--border-color); }
        .border-l { border-left: 1px solid var(--border-color); }
        .border-t { border-top: 1px solid var(--border-color); }

        /* =========================================
           Left Panel (Stencil)
           ========================================= */
        .panel-header {
            background-color: #f8fafc;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .app-title {
            font-size: 1.125rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .app-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .stencil-content {
            overflow-y: auto;
            flex: 1;
            padding: 1rem;
            background: var(--panel-bg);
            min-height: 0;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            align-content: start;
        }

        .group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
            margin-top: 1rem;
            grid-column: 1 / -1;
        }
        .group-title:first-child { margin-top: 0; }

        .dnd-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            background: white;
            cursor: grab;
            transition: all 0.2s;
        }

        .dnd-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-color);
        }

        .dnd-item:active { cursor: grabbing; }

        .shape-preview {
            border: 2px solid #1e293b;
            background: white;
            box-sizing: border-box;
        }

        .shape-circle { width: 40px; height: 40px; border-radius: 50%; }
        .shape-rect { width: 64px; height: 40px; border-radius: 6px; }
        .shape-diamond { width: 40px; height: 40px; transform: rotate(45deg) scale(0.8); margin: 4px; }

        .svg-icon-container {
            width: 40px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            color: #334155;
        }
        .svg-icon-container svg { width: 100%; height: 100%; overflow: visible; fill: currentColor; }

        .shape-swimlane {
            width: 64px; height: 48px;
            border: 2px solid #1e293b; border-top-width: 8px;
            display: flex; align-items: center; justify-content: center;
        }
        .swimlane-line { width: 100%; height: 1px; background: #cbd5e1; }

        .shape-text {
            width: 64px; height: 40px;
            display: flex; align-items: center; justify-content: center;
            border: 1px dashed #cbd5e1; background: transparent;
            font-size: 20px; font-weight: bold; color: #1e293b;
        }

        .item-label {
            font-size: 0.75rem; font-weight: 500;
            margin-top: 0.5rem; text-align: center;
        }

        /* =========================================
           Center Panel (Canvas)
           ========================================= */
        .toolbar {
            height: 48px; background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 1rem; z-index: 10; position: relative;
            flex-shrink: 0; overflow-x: auto; white-space: nowrap;
        }
        .toolbar::-webkit-scrollbar { height: 4px; }
        .toolbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 2px; }

        .btn-icon {
            background: none; border: none; padding: 6px; border-radius: 4px;
            cursor: pointer; color: var(--text-main);
            display: flex; align-items: center; justify-content: center; flex-shrink: 0;
        }
        .btn-icon:hover:not(:disabled) { background-color: #f1f5f9; }
        .btn-icon:disabled { opacity: 0.3; cursor: not-allowed; }
        .btn-icon svg { width: 20px; height: 20px; fill: currentColor; }

        .separator { width: 1px; height: 24px; background: var(--border-color); margin: 0 0.5rem; flex-shrink: 0; }

        .btn-text {
            padding: 6px 12px; font-size: 0.875rem; border-radius: 4px;
            cursor: pointer; border: 1px solid transparent; position: relative;
            white-space: nowrap; flex-shrink: 0;
        }
        .btn-primary { background-color: var(--primary-color); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-secondary { color: var(--text-main); border-color: var(--border-color); background: white; }
        .btn-secondary:hover { background-color: #f8fafc; }
        .btn-danger { color: #dc2626; }
        .btn-danger:hover { background-color: #fef2f2; }

        /* AI Button Style */
        .btn-ai-prompt {
            background: linear-gradient(135deg, #8b5cf6, #d946ef);
            color: white; border: none; font-weight: bold;
            box-shadow: 0 2px 4px rgba(139, 92, 246, 0.3);
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex; align-items: center; gap: 4px;
        }
        .btn-ai-prompt:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(139, 92, 246, 0.4);
            opacity: 0.95;
        }

        #canvas-wrapper {
            flex: 1; position: relative;
            background-color: var(--bg-color); overflow: hidden;
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px; cursor: default;
        }

        svg { display: block; overflow: visible; }
        .node-group { cursor: move; }
        .node-body { stroke: #1e293b; vector-effect: non-scaling-stroke; }
        .node-label { pointer-events: none; font-family: sans-serif; }
        .edge-label-text { font-size: 12px; fill: #475569; font-family: sans-serif; pointer-events: none; }
        .text-bg-rect { fill-opacity: 0.9; stroke: none; rx: 2px; }

        .connector-path {
            fill: none; stroke: #64748b; stroke-width: 2px;
            stroke-linejoin: round; stroke-linecap: round;
            pointer-events: stroke; cursor: pointer;
        }
        .connector-path:hover { stroke: var(--primary-color); stroke-width: 3px !important; }
        .connector-path.selected { stroke: var(--primary-color); stroke-width: 3px !important; }

        .port {
            fill: white; stroke: var(--primary-color); stroke-width: 1px; r: 3.5px;
            cursor: crosshair; opacity: 0; transition: opacity 0.2s, r 0.1s;
        }
        .node-group:hover .port { opacity: 1; }
        .port:hover { fill: var(--primary-color); r: 6px; opacity: 1; }

        .selected .node-body { stroke: var(--primary-color); stroke-dasharray: 5 5; }
        .selected.text-node .node-label { fill: var(--primary-color); text-decoration: underline; }

        .resize-handle {
            width: 10px; height: 10px; fill: var(--primary-color); stroke: white;
            stroke-width: 1px; cursor: nwse-resize; display: none;
        }
        .edge-handle {
            fill: var(--primary-color); stroke: white; stroke-width: 1px; r: 5px;
            cursor: move; display: none; opacity: 0.8;
        }
        .edge-handle:hover { r: 7px; opacity: 1; }
        .node-group.selected .resize-handle { display: block; }

        .rubberband {
            fill: rgba(59, 130, 246, 0.1); stroke: #3b82f6; stroke-width: 1px; pointer-events: none;
        }

        .quick-add-handle {
            fill: #fff; stroke: var(--primary-color); stroke-width: 1px;
            cursor: pointer; opacity: 0.9; transition: all 0.2s;
        }
        .quick-add-handle:hover { fill: var(--primary-color); opacity: 1; }
        .quick-add-symbol {
            pointer-events: none; stroke: var(--primary-color); stroke-width: 2px; stroke-linecap: round;
        }
        .quick-add-group:hover .quick-add-symbol { stroke: white; }

        /* =========================================
           Right Panel & Others
           ========================================= */
        .properties-panel { background: var(--panel-bg); display: flex; flex-direction: column; }
        .tabs {
            display: flex; border-bottom: 1px solid var(--border-color);
            background: #f8fafc; flex-shrink: 0;
        }
        .tab-btn {
            flex: 1; padding: 0.75rem; font-size: 0.8rem; font-weight: 600;
            color: var(--text-muted); border: none; background: none; cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .tab-btn:hover { color: var(--primary-color); background: #f1f5f9; }
        .tab-btn.active { color: var(--primary-color); border-bottom-color: var(--primary-color); background: white; }
        
        .panel-content { display: none; flex: 1; overflow-y: auto; padding: 1rem; min-height: 0; }
        .panel-content.active { display: block; }

        .prop-group { margin-bottom: 1rem; }
        .prop-label {
            display: block; font-size: 0.75rem; font-weight: 600;
            color: var(--text-muted); margin-bottom: 0.25rem;
        }
        .prop-input {
            width: 100%; padding: 0.5rem; font-size: 0.875rem;
            border: 1px solid var(--border-color); border-radius: 4px; outline: none;
        }
        .prop-input:focus { border-color: var(--primary-color); }
        .color-picker-row { display: flex; gap: 0.5rem; align-items: center; }

        .color-palette { display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; margin-top: 0.5rem; }
        .color-swatch {
            width: 100%; aspect-ratio: 1; border-radius: 4px; cursor: pointer;
            border: 1px solid #e2e8f0; transition: transform 0.1s;
        }
        .color-swatch:hover { transform: scale(1.1); border-color: var(--text-muted); }

        .dimension-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }

        .layer-list { list-style: none; padding: 0; margin: 0; }
        .layer-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 8px; margin-bottom: 4px; border: 1px solid var(--border-color);
            background: white; border-radius: 4px; cursor: grab; font-size: 0.8rem;
        }
        .layer-item:hover { border-color: var(--primary-color); }
        .layer-item:active { cursor: grabbing; }
        .layer-item.dragging { opacity: 0.5; background: var(--drag-placeholder); }
        .layer-item-content { display: flex; align-items: center; gap: 8px; flex: 1; overflow: hidden; }
        .layer-icon { width: 16px; height: 16px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
        .layer-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .layer-handle { color: #cbd5e1; cursor: grab; }

        #quick-add-menu {
            position: absolute; background: white; border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15); border-radius: 8px;
            padding: 8px; display: none; grid-template-columns: repeat(3, 1fr); gap: 8px; z-index: 100;
        }
        .quick-add-item {
            width: 40px; height: 40px; border: 1px solid var(--border-color);
            border-radius: 4px; display: flex; align-items: center; justify-content: center; cursor: pointer;
        }
        .quick-add-item:hover { background-color: #f1f5f9; border-color: var(--primary-color); }

        #export-menu {
            position: fixed; top: 0; left: 0; margin-top: 0;
            background: white; border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); border-radius: 4px;
            width: 180px; display: none; flex-direction: column; z-index: 1000;
        }
        .export-item {
            padding: 8px 12px; text-align: left; font-size: 0.875rem;
            color: var(--text-main); background: none; border: none; cursor: pointer;
        }
        .export-item:hover { background-color: #f1f5f9; }

        #toast {
            position: absolute; bottom: 1rem; right: 1rem;
            background: #1e293b; color: white; padding: 0.5rem 1rem;
            border-radius: 4px; font-size: 0.875rem; opacity: 0; transition: opacity 0.3s;
            pointer-events: none; z-index: 200;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.5); display: none; align-items: center; justify-content: center; z-index: 9999;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 8px; width: 90%; max-width: 600px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }
        .modal-textarea {
            width: 100%; height: 200px; margin: 10px 0; padding: 10px;
            border: 1px solid #444; border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace; font-size: 0.9rem; resize: vertical;
            background-color: #1e1e1e; color: #f0f0f0;
        }

        .instruction-box {
            background-color: #eff6ff; border-left: 4px solid #3b82f6;
            padding: 12px 16px; border-radius: 4px; margin-bottom: 15px;
            color: #1e293b; font-size: 0.85rem; line-height: 1.6;
        }
        .instruction-step { display: flex; margin-bottom: 6px; align-items: baseline; }
        .instruction-step-num { font-weight: bold; color: #3b82f6; margin-right: 8px; flex-shrink: 0; }
        .instruction-highlight {
            font-weight: bold; color: #1d4ed8; background: #dbeafe; padding: 0 4px; border-radius: 2px;
        }

        @media print {
            @page { size: auto; margin: 0mm; }
            body { background: white; overflow: visible; margin: 0; padding: 0; }
            .app-container { display: block; height: auto; width: 100%; }
            .flex-col.border-r, .properties-panel, .toolbar, #toast, #quick-add-menu, #export-menu, #ai-prompt-modal { display: none !important; }
            #canvas-wrapper {
                position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                overflow: visible; background: none; border: none; margin: 0;
            }
            svg#main-svg { width: 100%; height: 100%; overflow: visible; background-color: white; }
            #bg-rect { fill: white !important; }
            pattern#grid-pattern path { stroke: none !important; }
            .port, .resize-handle, .rubberband, #layer-ui { display: none !important; }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- LEFT PANEL -->
        <div class="flex flex-col border-r shadow-sm z-10 h-full overflow-hidden">
            <div class="panel-header">
                <div class="app-title">
                    <svg width="24" height="24" viewBox="0 0 256 256" fill="#3b82f6">
                        <path d="M200,168a32,32,0,0,0-30.37,22.18L130.3,109.84a8,8,0,0,0-12.6,0l-39.33,80.34A32,32,0,1,0,88,200a31.86,31.86,0,0,0-2.34-12l35.8-73.13,35.8,73.13A31.86,31.86,0,0,0,152,200a32,32,0,1,0,48-32Zm-144,48a16,16,0,1,1,16-16A16,16,0,0,1,56,216Zm96,0a16,16,0,1,1,16-16A16,16,0,0,1,152,216Zm48,0a16,16,0,1,1,16-16A16,16,0,0,1,200,216ZM96,64A32,32,0,1,1,64,32,32,32,0,0,1,96,64Zm8,53.48-18.1-37A47.85,47.85,0,0,0,128,112a47.85,47.85,0,0,0,42.1-31.54l-18.1,37A32,32,0,0,1,104,117.48ZM64,80a16,16,0,1,0-16-16A16,16,0,0,0,64,80Z"></path>
                    </svg>
                    BizFlow
                </div>
                <div class="app-subtitle">アクティビティ図作成ツール (v7.5)</div>
            </div>

            <div class="stencil-content">
                <div class="group-title">ノード</div>
                <div class="dnd-item" draggable="true" data-type="circle" title="開始/終了: フローの開始点や終了点を表します">
                    <div class="shape-preview shape-circle"></div><span class="item-label">開始 / 終了</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="rect" title="処理: 業務の作業やアクションを表します">
                    <div class="shape-preview shape-rect"></div><span class="item-label">処理</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="diamond" title="判断: 条件による分岐点（Yes/Noなど）を表します">
                    <div class="shape-preview shape-diamond"></div><span class="item-label">判断</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="db" title="データストア: データの保管や参照を表します">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 40 40"><path d="M 0 6 A 20 6 0 1 1 40 6 A 20 6 0 1 1 0 6 z M 0 6 L 0 34 A 20 6 0 0 0 40 34 L 40 6 A 20 6 0 0 1 0 6" fill="white" stroke="#1e293b" stroke-width="2"></path></svg>
                    </div><span class="item-label">データストア</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="text" title="テキスト: 注釈やコメントを記入します">
                    <div class="shape-text">T</div><span class="item-label">テキスト</span>
                </div>
                <div class="group-title">アイコン</div>
                <div class="dnd-item" draggable="true" data-type="icon-pc" title="パソコン: 端末操作やシステム利用を表します">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 17.575V4H4V17.575H20ZM22 2V19H13V21H16V23H8V21H11V19H2V2H22ZM6 6H18V15.5H6V6Z"/><rect x="6" y="6" width="12" height="9.5" fill="currentColor"/></svg>
                    </div><span class="item-label">パソコン</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="icon-doc" title="書類: 帳票やドキュメントを表します">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2ZM13 9V3.5L18.5 9H13Z"/></svg>
                    </div><span class="item-label">書類</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="icon-server" title="サーバー: システム処理やバックエンドを表します">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M2 20V4H22V20H2ZM4 6V10H20V6H4ZM4 12V18H20V12H4ZM6 7V9H8V7H6ZM6 13V15H8V13H6Z"/></svg>
                    </div><span class="item-label">サーバー</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="icon-user" title="ユーザー: 作業者や担当者を表します">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z"/></svg>
                    </div><span class="item-label">ユーザー</span>
                </div>
                <div class="group-title">コンテナ</div>
                <div class="dnd-item" draggable="true" data-type="swimlane" title="担当領域: 部署や役割ごとの区分け（レーン）を作成します">
                    <div class="shape-preview shape-swimlane"><div class="swimlane-line"></div></div><span class="item-label">担当領域</span>
                </div>
                <div style="height: 50px; grid-column: 1/-1;"></div>
            </div>
        </div>

        <!-- CENTER PANEL -->
        <div class="flex flex-col relative overflow-hidden h-full">
            <div class="toolbar">
                <div class="flex items-center gap-2">
                    <button id="btn-undo" class="btn-icon" title="元に戻す (Ctrl+Z)" disabled><svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"></path></svg></button>
                    <button id="btn-redo" class="btn-icon" title="やり直し (Ctrl+Y)" disabled><svg viewBox="0 0 24 24"><path d="M18.4 10.6C16.55 9 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"></path></svg></button>
                    <div class="separator"></div>
                    <button id="btn-home" class="btn-icon" title="元の位置に戻る"><svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" /></svg></button>
                    <button id="btn-fit" class="btn-icon" title="大きさを100%に戻す"><svg viewBox="0 0 24 24"><path d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6z"></path></svg></button>
                    <div class="separator"></div>
                    <button id="btn-zoom-out" class="btn-icon" title="縮小"><svg viewBox="0 0 24 24"><path d="M19 13H5v-2h14v2z"></path></svg></button>
                    <span id="zoom-level" style="font-size: 0.875rem; font-family: monospace; width: 48px; text-align: center;">100%</span>
                    <button id="btn-zoom-in" class="btn-icon" title="拡大"><svg viewBox="0 0 24 24"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></svg></button>
                </div>
                <div class="flex items-center gap-2">
                    <button id="btn-ai-prompt" class="btn-text btn-ai-prompt">✨ AIを使って作成</button>
                    <div class="separator"></div>
                    <button id="btn-clear" class="btn-text btn-danger">全削除</button>
                    <div class="separator"></div>
                    <button id="btn-import" class="btn-text btn-secondary">JSONから読込</button>
                    <div style="position: relative;">
                        <button id="btn-export-menu" class="btn-text btn-primary">保存 ▼</button>
                    </div>
                </div>
            </div>

            <div id="export-menu">
                <button class="export-item" id="export-json">JSONファイルとして保存</button>
                <button class="export-item" id="export-png">PNG画像 (背景透過)</button>
                <button class="export-item" id="export-jpeg">JPEG画像 (背景あり)</button>
                <button class="export-item" id="export-svg">SVG形式で保存 (New)</button>
                <button class="export-item" id="export-pdf">PDF印刷 / 保存</button>
            </div>

            <div id="canvas-wrapper">
                <svg id="main-svg" width="100%" height="100%">
                    <defs>
                        <pattern id="grid-pattern" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e2e8f0" stroke-width="1" />
                        </pattern>
                        <marker id="arrow-end" markerWidth="7" markerHeight="7" refX="6" refY="3.5" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,7 L7,3.5 z" fill="#64748b" /></marker>
                        <marker id="arrow-start" markerWidth="7" markerHeight="7" refX="1" refY="3.5" orient="auto" markerUnits="strokeWidth"><path d="M7,0 L7,7 L0,3.5 z" fill="#64748b" /></marker>
                    </defs>
                    <rect id="bg-rect" width="100%" height="100%" fill="none"></rect>
                    <g id="viewport-group">
                        <g id="layer-swimlanes"></g>
                        <g id="layer-edges"></g>
                        <g id="layer-nodes"></g>
                        <g id="layer-labels"></g>
                        <g id="layer-ui"></g>
                    </g>
                </svg>
            </div>

            <div id="quick-add-menu">
                <div class="quick-add-item" data-type="rect" title="処理を追加"><div class="shape-preview shape-rect" style="width:24px; height:16px;"></div></div>
                <div class="quick-add-item" data-type="diamond" title="判断を追加"><div class="shape-preview shape-diamond" style="width:20px; height:20px;"></div></div>
                <div class="quick-add-item" data-type="db" title="DBを追加"><div class="svg-icon-container" style="transform: scale(0.6);"><svg viewBox="0 0 40 40"><path d="M 0 6 A 20 6 0 1 1 40 6 A 20 6 0 1 1 0 6 z M 0 6 L 0 34 A 20 6 0 0 0 40 34 L 40 6 A 20 6 0 0 1 0 6" fill="white" stroke="#1e293b" stroke-width="2"></path></svg></div></div>
                <div class="quick-add-item" data-type="circle" title="終了を追加"><div class="shape-preview shape-circle" style="width:20px; height:20px;"></div></div>
            </div>

            <div id="toast">保存しました</div>
        </div>

        <!-- RIGHT PANEL -->
        <div class="properties-panel border-l z-10 h-full overflow-hidden">
            <div class="tabs">
                <button class="tab-btn active" data-tab="prop">プロパティ</button>
                <button class="tab-btn" data-tab="layer">レイヤー</button>
            </div>

            <!-- Property Tab -->
            <div id="tab-prop" class="panel-content active">
                <div id="props-empty" style="text-align: center; color: var(--text-muted); font-style: italic; margin-top: 2rem;">要素を選択すると<br>詳細が表示されます</div>
                <div id="props-multi" style="text-align: center; color: var(--text-muted); font-style: italic; margin-top: 2rem; display: none;">複数項目を選択中</div>
                <div id="props-content" style="display: none;">
                    <div id="group-node-type" class="prop-group">
                        <label class="prop-label">種類 (Type)</label>
                        <select id="prop-type" class="prop-input">
                            <option value="rect">処理 (Action)</option>
                            <option value="circle">開始/終了 (Circle)</option>
                            <option value="diamond">判断 (Decision)</option>
                            <option value="db">データストア (DB)</option>
                            <option value="text">テキスト (Text)</option>
                            <option value="swimlane">担当領域 (Swimlane)</option>
                            <option value="icon-pc">アイコン: PC</option>
                            <option value="icon-doc">アイコン: 書類</option>
                            <option value="icon-server">アイコン: サーバー</option>
                            <option value="icon-user">アイコン: ユーザー</option>
                        </select>
                    </div>
                    <div id="group-edge-style" class="prop-group" style="display:none;">
                        <label class="prop-label">マーカー (矢印)</label>
                        <select id="prop-edge-marker" class="prop-input">
                            <option value="none">なし</option>
                            <option value="end">終了点のみ (→)</option>
                            <option value="start">開始点のみ (←)</option>
                            <option value="both">両端 (↔)</option>
                        </select>
                        <div style="margin-top: 10px; font-size: 0.75rem; color: #64748b;">※ 線上の青いハンドルをドラッグすると経路を調整できます。ダブルクリックでリセットします。</div>
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">ID</label>
                        <input type="text" id="prop-id" class="prop-input" readonly style="background: #f1f5f9; font-family: monospace;">
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">ラベルテキスト</label>
                        <textarea id="prop-label" rows="3" class="prop-input"></textarea>
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">フォント設定</label>
                        <div class="dimension-inputs">
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">サイズ (px)</label><input type="number" id="prop-font-size" class="prop-input" min="8" max="72"></div>
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">色</label><input type="color" id="prop-text-color" style="width: 100%; height: 34px; cursor: pointer;"></div>
                        </div>
                        <div style="margin-top:0.5rem;">
                            <label style="font-size: 0.7rem; color: #94a3b8;">テキスト背景</label>
                            <div class="color-picker-row">
                                <input type="color" id="prop-text-bg-color" style="height: 32px; width: 64px; cursor: pointer;">
                                <button id="btn-text-bg-none" class="btn-text btn-secondary" style="font-size: 0.75rem;">なし</button>
                            </div>
                        </div>
                    </div>
                    <div class="prop-group" id="group-dimensions">
                        <label class="prop-label">サイズ</label>
                        <div class="dimension-inputs">
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">幅 (W)</label><input type="number" id="prop-w" class="prop-input"></div>
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">高さ (H)</label><input type="number" id="prop-h" class="prop-input"></div>
                        </div>
                    </div>
                    <div class="prop-group" id="group-style">
                        <label class="prop-label">スタイル</label>
                        <div style="margin-bottom: 0.5rem;">
                            <label style="font-size: 0.7rem; color: #94a3b8;">枠線太さ (px)</label>
                            <input type="number" id="prop-stroke-width" class="prop-input" min="0" max="10" step="0.5" value="2">
                        </div>
                        <div>
                            <label style="font-size: 0.7rem; color: #94a3b8;">図形背景色</label>
                            <div class="color-picker-row">
                                <input type="color" id="prop-color" style="height: 32px; width: 64px; cursor: pointer;">
                                <button id="btn-reset-color" class="btn-text btn-secondary" style="font-size: 0.75rem;">リセット</button>
                            </div>
                            <div class="color-palette" id="color-palette">
                                <div class="color-swatch" style="background: #fee2e2;" data-color="#fee2e2" title="Red 100"></div>
                                <div class="color-swatch" style="background: #ffedd5;" data-color="#ffedd5" title="Orange 100"></div>
                                <div class="color-swatch" style="background: #fef9c3;" data-color="#fef9c3" title="Yellow 100"></div>
                                <div class="color-swatch" style="background: #dcfce7;" data-color="#dcfce7" title="Green 100"></div>
                                <div class="color-swatch" style="background: #dbeafe;" data-color="#dbeafe" title="Blue 100"></div>
                                <div class="color-swatch" style="background: #e0e7ff;" data-color="#e0e7ff" title="Indigo 100"></div>
                                <div class="color-swatch" style="background: #f3e8ff;" data-color="#f3e8ff" title="Purple 100"></div>
                                <div class="color-swatch" style="background: #fae8ff;" data-color="#fae8ff" title="Fuchsia 100"></div>
                                <div class="color-swatch" style="background: #ffe4e6;" data-color="#ffe4e6" title="Rose 100"></div>
                                <div class="color-swatch" style="background: #f1f5f9;" data-color="#f1f5f9" title="Slate 100"></div>
                            </div>
                        </div>
                    </div>
                    <div style="height: 50px;"></div>
                </div>
            </div>
            <!-- Layer Tab -->
            <div id="tab-layer" class="panel-content">
                <div style="font-size:0.75rem; color:#64748b; margin-bottom:0.5rem;">上にある項目が手前に表示されます。<br>ドラッグで順序変更可能です。</div>
                <ul id="layer-list" class="layer-list"></ul>
            </div>
        </div>
    </div>

    <!-- AI Prompt Modal -->
    <div id="ai-prompt-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="margin-bottom: 10px; font-weight: bold; color: #334155;">AIプロンプト作成テンプレート</h3>
            <div class="instruction-box">
                <div class="instruction-step"><span class="instruction-step-num">1.</span><span>下の黒い画面にある <span class="instruction-highlight">{{{{{ここに業務フローの内容を記述}}}}}</span> の部分を、実際の業務内容（例：メールを受信したら確認する等）に書き換えてください。</span></div>
                <div class="instruction-step"><span class="instruction-step-num">2.</span><span>書き換えたら全文をコピーし、ChatGPTなどのAIに貼り付けて指示を出してください。</span></div>
                <div class="instruction-step"><span class="instruction-step-num">3.</span><span>AIが作成したコードを <span class="instruction-highlight">.json</span> という拡張子（例: flow.json）でPCに保存してください。</span></div>
                <div class="instruction-step"><span class="instruction-step-num">4.</span><span>この画面上部の「JSONから読込」ボタンから、保存したファイルを読み込んでください。</span></div>
            </div>
            <textarea id="ai-prompt-text" class="modal-textarea">
# **業務フローの内容**

{{{{{ここに業務フローの内容を記述}}}}} (例：社内のPCセットアップ業務。管理者がPCを準備し、ユーザーに書類を渡す。その後ユーザーが受領確認を行う。)

# **命令**

あなたは業務フロー図作成ツール「BizFlow Designer」のデータ生成エンジンです。 上記の【業務フローの内容】を読み解き、定義された【JSONフォーマット仕様】に厳密に従ってJSONデータを出力してください。

# **制約条件とルール**

1. **座標計算（重要）**:  
   * 各ノードは重ならないように配置すること。  
   * 業務の流れに従って、**左から右へ**、または**上から下へ**順序よく座標(x, y)を計算して設定すること。  
   * 座標は `x: 0, y: 0` から `x: 800, y: 600` 程度の範囲に収めること。  
2. **配線の最適化（重要）**:  
   * 複数の接続線が特定の図形に集中する場合、線が重なって視認性が落ちるのを防ぐため、後述する\*\*拡張ポート（`top-L`, `top-R`など）\*\*を積極的に使い分けること。  
3. **ID**: 全てユニークな文字列にすること（例: `node_1`, `edge_1`）。  
4. **JSON形式**: 出力はJSONデータのみとすること（解説不要）。

# **JSONフォーマット仕様**

以下の仕様に従ってください。

## **1\. ノード定義 (nodes)**

各図形は以下のプロパティを持ちます。

* `type`: 図形の種類（以下のリストから適切なものを選択）  
  * `circle`: 開始 / 終了 (サイズ推奨: w:60, h:60)  
  * `rect`: 処理 (サイズ推奨: w:120, h:60)  
  * `diamond`: 判断 (サイズ推奨: w:80, h:80)  
  * `db`: データストア (サイズ推奨: w:60, h:60)  
  * `swimlane`: 担当領域/スイムレーン (サイズ推奨: w:300\~600, h:400, 枠線太さ推奨: 0.5)  
  * `text`: テキストメモ  
  * `icon-pc`: PCアイコン  
  * `icon-doc`: 書類アイコン  
  * `icon-server`: サーバーアイコン  
  * `icon-user`: ユーザーアイコン  
* `x`, `y`: 配置座標 (数値)  
* `w`, `h`: 幅と高さ (数値)  
  * **注記**: 上記の推奨サイズはあくまで目安です。ラベルの文字数が多い場合や、レイアウトの規模・内容に応じて、**視認しやすいサイズに適宜変更・拡大しても構いません**。  
* `label`: 表示するテキスト (改行は `\n`)  
* `bgColor`: 背景色 (任意。例: `#ffffff`, `#dbeafe`(青系), `#ffe4e6`(赤系))

## **2\. 接続定義 (edges)**

ノード間の接続線です。各図形の4面（上下左右）には、それぞれ3つずつの接続点（ポート）が存在します。

* `source`: 接続元のノードID  
* `target`: 接続先のノードID  
* `sourcePort`, `targetPort`: 接続位置  
  * 以下の12種類から選択可能です。線が重ならないように使い分けてください。  
  * **上辺**: `top` (中央), `top-L` (左寄り), `top-R` (右寄り)  
  * **下辺**: `bottom` (中央), `bottom-L` (左寄り), `bottom-R` (右寄り)  
  * **左辺**: `left` (中央), `left-L` (上寄り), `left-R` (下寄り)  
  * **右辺**: `right` (中央), `right-L` (上寄り), `right-R` (下寄り)  
  * ※ `-L` や `-R` は、その辺に向かって立ったときの左右を指します（例: `top-L` は上辺の左側）。  
* `label`: 線の上に表示する文字（条件分岐の「Yes/No」など）

# **出力JSONスキーマ**

{  
  "nodes": \[  
    {  
      "id": "node\_start",  
      "type": "circle",  
      "x": 100,  
      "y": 100,  
      "w": 60,  
      "h": 60,  
      "label": "開始",  
      "bgColor": "\#ffffff"  
    }  
    // ...他のノード  
  \],  
  "edges": \[  
    {  
      "id": "edge\_1",  
      "source": "node\_start",  
      "sourcePort": "right",   
      "target": "node\_process\_1",  
      "targetPort": "left-L",   
      "label": ""  
    },  
    {  
      "id": "edge\_2",  
      "source": "node\_start",  
      "sourcePort": "right",   
      "target": "node\_process\_2",  
      "targetPort": "left-R",   
      "label": ""  
    }  
    // ...他のエッジ  
  \]  
}
            </textarea>
            <div class="flex" style="justify-content: space-between; align-items: center;">
                <button id="btn-reset-prompt" class="btn-text btn-danger" style="margin-right: auto;">元に戻す</button>
                <div class="flex gap-2">
                    <button id="btn-copy-prompt" class="btn-text btn-primary">コピー</button>
                    <button id="btn-close-modal" class="btn-text btn-secondary">閉じる</button>
                </div>
            </div>
        </div>
    </div>
    <input type="file" id="file-input" accept=".json" style="display: none;">

    <script>
        /** * BizFlow Designer - Refactored v7.5
         * モジュール構成:
         * 1. CONFIG: 定数設定
         * 2. Utils: ユーティリティ関数
         * 3. PathRouter: 経路計算ロジック
         * 4. State: 状態管理 (Store)
         * 5. Renderer: 描画ロジック
         * 6. Events: イベントハンドラ
         * 7. Main: 初期化
         */

        (function () {
            'use strict';

            // --- 1. CONFIG ---
            const CONFIG = {
                GRID_SIZE: 10,
                MIN_SIZE: 24,
                STORAGE_KEY: 'bizflow_offline_data_v7',
                DEFAULT_AI_PROMPT_TEXT: document.getElementById('ai-prompt-text').value // 初期値をHTMLから取得して保持
            };

            // --- 2. Utils ---
            const Utils = {
                uuid: () => 'id-' + Math.random().toString(36).substr(2, 9),
                snap: (val) => Math.round(val / CONFIG.GRID_SIZE) * CONFIG.GRID_SIZE,

                getMousePos: (evt, svgEl, pan, zoom) => {
                    let cx, cy;
                    if (evt.touches && evt.touches.length > 0) {
                        cx = evt.touches[0].clientX; cy = evt.touches[0].clientY;
                    } else if (evt.clientX !== undefined) {
                        cx = evt.clientX; cy = evt.clientY;
                    } else {
                        return { x: 0, y: 0 };
                    }
                    const CTM = svgEl.getScreenCTM();
                    if (!CTM) return { x: 0, y: 0 };
                    return {
                        x: (cx - CTM.e - pan.x) / zoom,
                        y: (cy - CTM.f - pan.y) / zoom
                    };
                },

                createMultilineText: (text, x, y, isSwimlane, size, color, isTextNode) => {
                    const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const lines = text.split('\n');
                    const fontSize = size || 14;
                    const lineHeight = fontSize * 1.2;
                    t.style.fontSize = fontSize + 'px';
                    if (color) t.style.fill = color;

                    let startY = y;
                    if (!isSwimlane && !isTextNode) startY = y - ((lines.length - 1) * lineHeight) / 2 + (fontSize * 0.35);
                    if (isTextNode) startY = y - ((lines.length - 1) * lineHeight) / 2 + (fontSize * 0.35);

                    lines.forEach((line, i) => {
                        const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                        tspan.textContent = line;
                        tspan.setAttribute('x', x);
                        tspan.setAttribute('dy', i === 0 ? 0 : lineHeight);
                        if (i === 0) tspan.setAttribute('y', startY);
                        t.appendChild(tspan);
                    });
                    return t;
                },

                parsePathPoints: (d) => {
                    const parts = d.split(' ');
                    const points = [];
                    for (let i = 0; i < parts.length; i += 3) {
                        if (parts[i] === 'M' || parts[i] === 'L') points.push({ x: parseFloat(parts[i + 1]), y: parseFloat(parts[i + 2]) });
                    }
                    return points;
                },

                showToast: (msg) => {
                    const t = document.getElementById('toast');
                    t.textContent = msg; t.style.opacity = '1';
                    setTimeout(() => t.style.opacity = '0', 2000);
                }
            };

            // --- 3. PathRouter (Geometry Logic) ---
            const PathRouter = {
                getPortPos: (node, dirStr) => {
                    if (!dirStr) return { x: node.x + node.w / 2, y: node.y + node.h / 2 };
                    const parts = dirStr.split('-');
                    const mainDir = parts[0];
                    const subDir = parts[1];
                    let x = node.x, y = node.y;
                    let offsetRatio = 0.5;
                    if (subDir === 'L') offsetRatio = 0.25;
                    if (subDir === 'R') offsetRatio = 0.75;

                    if (mainDir === 'top') { x += node.w * offsetRatio; y = node.y; }
                    else if (mainDir === 'bottom') { x += node.w * offsetRatio; y = node.y + node.h; }
                    else if (mainDir === 'left') { x = node.x; y += node.h * offsetRatio; }
                    else if (mainDir === 'right') { x = node.x + node.w; y += node.h * offsetRatio; }
                    else { x += node.w / 2; y += node.h / 2; }
                    return { x, y };
                },

                getDirFromPortStr: (dirStr) => dirStr ? dirStr.split('-')[0] : 'top',

                getEdgeLabelPosition: (d) => {
                    const points = Utils.parsePathPoints(d);
                    if (points.length < 2) return { x: 0, y: 0, orientation: 'horizontal' };
                    let p1, p2;
                    if (points.length === 2) { p1 = points[0]; p2 = points[1]; }
                    else if (points.length >= 4) {
                        const mid = Math.floor(points.length / 2);
                        if (mid > 0) { p1 = points[mid - 1]; p2 = points[mid]; } else { p1 = points[0]; p2 = points[1]; }
                    } else { p1 = points[0]; p2 = points[points.length - 1]; }

                    const mx = (p1.x + p2.x) / 2;
                    const my = (p1.y + p2.y) / 2;
                    const orientation = Math.abs(p1.x - p2.x) > Math.abs(p1.y - p2.y) ? 'horizontal' : 'vertical';
                    return { x: mx, y: my, orientation };
                },

                generatePathString: (s, sourceDir, t, targetDir) => {
                    let stub = 10;
                    let sx = s.x, sy = s.y, tx = t.x, ty = t.y;
                    const dist = Math.sqrt(Math.pow(tx - sx, 2) + Math.pow(ty - sy, 2));
                    const isAlignedX = Math.abs(tx - sx) < 1;
                    const isAlignedY = Math.abs(ty - sy) < 1;

                    if ((isAlignedX && (sourceDir === 'top' || sourceDir === 'bottom') && (targetDir === 'top' || targetDir === 'bottom')) ||
                        (isAlignedY && (sourceDir === 'left' || sourceDir === 'right') && (targetDir === 'left' || targetDir === 'right'))) {
                        return `M ${s.x} ${s.y} L ${t.x} ${t.y}`;
                    }

                    if (sourceDir === 'top') sy -= stub; else if (sourceDir === 'bottom') sy += stub; else if (sourceDir === 'left') sx -= stub; else if (sourceDir === 'right') sx += stub;
                    if (targetDir === 'top') ty -= stub; else if (targetDir === 'bottom') ty += stub; else if (targetDir === 'left') tx -= stub; else if (targetDir === 'right') tx += stub;

                    let path = `M ${s.x} ${s.y} L ${sx} ${sy}`;
                    const dx = tx - sx, dy = ty - sy;
                    const isVertS = (sourceDir === 'top' || sourceDir === 'bottom');
                    const isVertT = (targetDir === 'top' || targetDir === 'bottom');

                    if (isVertS && isVertT) {
                        if ((sourceDir === 'bottom' && ty > sy) || (sourceDir === 'top' && ty < sy)) {
                            const midY = sy + dy / 2; path += ` L ${sx} ${midY} L ${tx} ${midY} L ${tx} ${ty}`;
                        } else {
                            if (Math.abs(sx - tx) < stub * 2) {
                                const detourX = Math.max(sx, tx) + stub; path += ` L ${detourX} ${sy} L ${detourX} ${ty} L ${tx} ${ty}`;
                            } else {
                                const midY = sy + dy / 2; path += ` L ${sx} ${midY} L ${tx} ${midY} L ${tx} ${ty}`;
                            }
                        }
                    } else if (!isVertS && !isVertT) {
                        if ((sourceDir === 'right' && tx > sx) || (sourceDir === 'left' && tx < sx)) {
                            const midX = sx + dx / 2; path += ` L ${midX} ${sy} L ${midX} ${ty} L ${tx} ${ty}`;
                        } else {
                            const midYDetour = (sy + ty) / 2; path += ` L ${sx} ${midYDetour} L ${tx} ${midYDetour} L ${tx} ${ty}`;
                        }
                    } else {
                        const cornerX = (isVertS) ? sx : tx;
                        const cornerY = (isVertS) ? ty : sy;
                        let bad = false;
                        if (sourceDir === 'top' && cornerY > sy) bad = true;
                        if (sourceDir === 'bottom' && cornerY < sy) bad = true;
                        if (sourceDir === 'left' && cornerX > sx) bad = true;
                        if (sourceDir === 'right' && cornerX < sx) bad = true;
                        if (targetDir === 'top' && cornerY > ty) bad = true;
                        if (targetDir === 'bottom' && cornerY < ty) bad = true;
                        if (targetDir === 'left' && cornerX < tx) bad = true;
                        if (targetDir === 'right' && cornerX > tx) bad = true;

                        if (!bad) { path += ` L ${cornerX} ${cornerY} L ${tx} ${ty}`; }
                        else { if (isVertS) path += ` L ${sx} ${ty} L ${tx} ${ty}`; else path += ` L ${tx} ${sy} L ${tx} ${ty}`; }
                    }
                    path += ` L ${t.x} ${t.y}`;
                    return path;
                },

                calculateOrthogonalPathPointToPoint: (p1, dir1, p2, dir2) => {
                    const d1 = dir1 || (Math.abs(p1.x - p2.x) > Math.abs(p1.y - p2.y) ? (p2.x > p1.x ? 'right' : 'left') : (p2.y > p1.y ? 'bottom' : 'top'));
                    const d2 = dir2 || (d1 === 'left' ? 'right' : d1 === 'right' ? 'left' : d1 === 'top' ? 'bottom' : 'top');
                    return PathRouter.generatePathString(p1, d1, p2, d2);
                },

                getManhattanPath: (source, sourcePortStr, target, targetPortStr, waypoints) => {
                    const start = PathRouter.getPortPos(source, sourcePortStr);
                    const end = PathRouter.getPortPos(target, targetPortStr);
                    const sDir = PathRouter.getDirFromPortStr(sourcePortStr);
                    const tDir = PathRouter.getDirFromPortStr(targetPortStr);

                    if (!waypoints || waypoints.length === 0) {
                        return PathRouter.generatePathString(start, sDir, end, tDir);
                    }

                    let path = `M ${start.x} ${start.y}`;
                    let curr = start;
                    let currDir = sDir;
                    waypoints.forEach((wp) => {
                        const segmentPath = PathRouter.calculateOrthogonalPathPointToPoint(curr, currDir, wp, null);
                        path += ' ' + segmentPath.replace(/^M [\d\.]+ [\d\.]+ /, '');
                        curr = wp;
                        currDir = null;
                    });
                    const finalSegment = PathRouter.calculateOrthogonalPathPointToPoint(curr, currDir, end, tDir);
                    path += ' ' + finalSegment.replace(/^M [\d\.]+ [\d\.]+ /, '');
                    return path;
                }
            };

            // --- 4. State Management (Store) ---
            const State = {
                data: {
                    nodes: [], edges: [], zoom: 1, pan: { x: 0, y: 0 },
                    selection: [], clipboard: null, history: [], historyIndex: -1,
                    // UI Interaction State
                    isDragging: false, dragTarget: null, dragStart: { x: 0, y: 0, rawX: 0, rawY: 0 },
                    dragItemOffset: {}, tempLine: null, rubberbandRect: null,
                    quickAdd: { visible: false, sourceNodeId: null, portDir: null, x: 0, y: 0 },
                    activeTab: 'prop', layerDragIdx: null, draggingHandle: { edgeId: null, index: -1 }
                },

                saveHistory: () => {
                    const s = State.data;
                    if (s.historyIndex < s.history.length - 1) s.history = s.history.slice(0, s.historyIndex + 1);
                    const json = JSON.stringify({ nodes: s.nodes, edges: s.edges });
                    s.history.push(json);
                    s.historyIndex++;
                    Renderer.updateBtns();
                    try { localStorage.setItem(CONFIG.STORAGE_KEY, json); } catch (e) { }
                    Utils.showToast('保存しました');
                },

                undo: () => {
                    if (State.data.historyIndex > 0) {
                        State.data.historyIndex--;
                        State.restore(State.data.history[State.data.historyIndex]);
                    }
                },

                redo: () => {
                    if (State.data.historyIndex < State.data.history.length - 1) {
                        State.data.historyIndex++;
                        State.restore(State.data.history[State.data.historyIndex]);
                    }
                },

                restore: (jsonStr) => {
                    const d = JSON.parse(jsonStr);
                    State.data.nodes = d.nodes;
                    State.data.edges = d.edges;
                    State.data.selection = [];
                    Renderer.render();
                    Renderer.updateBtns();
                },

                updateSelectedProps: (key, value, isNumeric = false) => {
                    let changed = false;
                    State.data.selection.forEach(id => {
                        const n = State.data.nodes.find(node => node.id === id);
                        const e = State.data.edges.find(edge => edge.id === id);
                        const target = n || e;
                        if (target) { target[key] = isNumeric ? parseFloat(value) : value; changed = true; }
                    });
                    if (changed) Renderer.render();
                    return changed;
                }
            };

            // --- 5. Renderer ---
            const Renderer = {
                dom: {}, // Cache DOM elements here

                init: () => {
                    Renderer.dom = {
                        svg: document.getElementById('main-svg'),
                        viewport: document.getElementById('viewport-group'),
                        layers: {
                            swimlanes: document.getElementById('layer-swimlanes'),
                            nodes: document.getElementById('layer-nodes'),
                            edges: document.getElementById('layer-edges'),
                            labels: document.getElementById('layer-labels'),
                            ui: document.getElementById('layer-ui')
                        },
                        propsPanel: {
                            empty: document.getElementById('props-empty'),
                            multi: document.getElementById('props-multi'),
                            content: document.getElementById('props-content'),
                            groups: {
                                nodeType: document.getElementById('group-node-type'),
                                dim: document.getElementById('group-dimensions'),
                                style: document.getElementById('group-style'),
                                edge: document.getElementById('group-edge-style')
                            },
                            inputs: {
                                id: document.getElementById('prop-id'),
                                label: document.getElementById('prop-label'),
                                fontSize: document.getElementById('prop-font-size'),
                                textColor: document.getElementById('prop-text-color'),
                                textBgColor: document.getElementById('prop-text-bg-color'),
                                type: document.getElementById('prop-type'),
                                w: document.getElementById('prop-w'),
                                h: document.getElementById('prop-h'),
                                color: document.getElementById('prop-color'),
                                strokeWidth: document.getElementById('prop-stroke-width'),
                                edgeMarker: document.getElementById('prop-edge-marker')
                            }
                        },
                        layerList: document.getElementById('layer-list'),
                        zoomLevel: document.getElementById('zoom-level'),
                        buttons: {
                            undo: document.getElementById('btn-undo'),
                            redo: document.getElementById('btn-redo')
                        },
                        quickAddMenu: document.getElementById('quick-add-menu')
                    };
                },

                render: () => {
                    const { layers, viewport } = Renderer.dom;
                    const { nodes, edges, pan, zoom, selection, tempLine, rubberbandRect } = State.data;

                    // Clear layers
                    layers.swimlanes.innerHTML = '';
                    layers.nodes.innerHTML = '';
                    layers.edges.innerHTML = '';
                    layers.labels.innerHTML = '';

                    // Clear UI layer except temp elements
                    const tempChildren = Array.from(layers.ui.children);
                    tempChildren.forEach(c => {
                        if (c !== tempLine && c !== rubberbandRect) layers.ui.removeChild(c);
                    });

                    viewport.setAttribute('transform', `translate(${pan.x}, ${pan.y}) scale(${zoom})`);

                    // Render Edges
                    edges.forEach(edge => Renderer.renderEdge(edge, nodes, selection));

                    // Render Nodes
                    nodes.forEach(node => Renderer.renderNode(node, selection));

                    // Render Selection UI (Quick add handles etc)
                    if (selection.length === 1) {
                        const node = nodes.find(n => n.id === selection[0]);
                        if (node && !node.type.startsWith('icon-') && node.type !== 'swimlane' && node.type !== 'text') {
                            Renderer.renderQuickAddHandles(node);
                        }
                    }

                    if (State.data.activeTab === 'layer') Renderer.updateLayerPanel();
                    Renderer.updatePropsPanel();
                },

                renderEdge: (edge, nodes, selection) => {
                    const sourceNode = nodes.find(n => n.id === edge.source);
                    const targetNode = nodes.find(n => n.id === edge.target);
                    if (!sourceNode || !targetNode) return;

                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.dataset.id = edge.id; group.style.cursor = 'pointer';
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const isSelected = selection.includes(edge.id);
                    path.setAttribute('class', `connector-path ${isSelected ? 'selected' : ''}`);

                    const d = PathRouter.getManhattanPath(sourceNode, edge.sourcePort, targetNode, edge.targetPort, edge.waypoints);
                    path.setAttribute('d', d);

                    const markerType = edge.marker || 'end';
                    if (markerType === 'end' || markerType === 'both') path.setAttribute('marker-end', 'url(#arrow-end)');
                    if (markerType === 'start' || markerType === 'both') path.setAttribute('marker-start', 'url(#arrow-start)');

                    group.appendChild(path);
                    group.addEventListener('mousedown', (e) => { Events.handleSelection(e, edge.id); e.stopPropagation(); });
                    Renderer.dom.layers.edges.appendChild(group);

                    // Handles for editing
                    if (isSelected) Renderer.renderEdgeHandles(edge, d);

                    // Label
                    if (edge.label) Renderer.renderEdgeLabel(edge, d);
                },

                renderEdgeHandles: (edge, d) => {
                    const { layers } = Renderer.dom;
                    // Existing Waypoints
                    if (edge.waypoints) {
                        edge.waypoints.forEach((wp, idx) => {
                            const h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            h.setAttribute('class', 'edge-handle');
                            h.setAttribute('cx', wp.x); h.setAttribute('cy', wp.y);
                            h.style.display = 'block';
                            h.addEventListener('mousedown', (e) => {
                                e.stopPropagation();
                                State.data.isDragging = true;
                                State.data.dragTarget = 'edge-handle';
                                State.data.draggingHandle = { edgeId: edge.id, index: idx };
                                State.data.dragStart = Utils.getMousePos(e, Renderer.dom.svg, State.data.pan, State.data.zoom);
                            });
                            h.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                edge.waypoints.splice(idx, 1);
                                State.saveHistory(); Renderer.render();
                            });
                            layers.ui.appendChild(h);
                        });
                    }
                    // Midpoints for adding new waypoints
                    const points = Utils.parsePathPoints(d);
                    for (let i = 0; i < points.length - 1; i++) {
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        if (Math.abs(p1.x - p2.x) > 20 || Math.abs(p1.y - p2.y) > 20) {
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;
                            const h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            h.setAttribute('class', 'edge-handle');
                            h.setAttribute('cx', midX); h.setAttribute('cy', midY);
                            h.style.display = 'block';
                            h.style.fill = '#cbd5e1';
                            h.addEventListener('mousedown', (e) => {
                                e.stopPropagation();
                                if (!edge.waypoints) edge.waypoints = [];
                                edge.waypoints.push({ x: midX, y: midY });
                                State.data.isDragging = true;
                                State.data.dragTarget = 'edge-handle';
                                State.data.draggingHandle = { edgeId: edge.id, index: edge.waypoints.length - 1 };
                                State.saveHistory(); Renderer.render();
                            });
                            layers.ui.appendChild(h);
                        }
                    }
                },

                renderEdgeLabel: (edge, d) => {
                    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const center = PathRouter.getEdgeLabelPosition(d);
                    const bgColor = (edge.textBgColor && edge.textBgColor !== 'transparent') ? edge.textBgColor : '#ffffff';
                    const lines = edge.label.split('\n'); const fs = edge.fontSize || 14;
                    const maxLineLen = Math.max(...lines.map(l => l.length));
                    const w = Math.max(20, maxLineLen * (fs * 0.7) + 10);
                    const h = lines.length * (fs * 1.2) + 4;
                    const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    bg.setAttribute('class', 'text-bg-rect'); bg.setAttribute('fill', bgColor);
                    bg.setAttribute('x', center.x - w / 2); bg.setAttribute('y', center.y - h / 2);
                    bg.setAttribute('width', w); bg.setAttribute('height', h);
                    labelGroup.style.cursor = 'pointer';
                    labelGroup.addEventListener('mousedown', (e) => { Events.handleSelection(e, edge.id); e.stopPropagation(); });
                    labelGroup.appendChild(bg);
                    const text = Utils.createMultilineText(edge.label, center.x, center.y, false, edge.fontSize, edge.textColor, false);
                    text.setAttribute('class', 'edge-label-text'); text.setAttribute('text-anchor', 'middle');
                    text.querySelectorAll('tspan').forEach(ts => ts.setAttribute('x', center.x));
                    labelGroup.appendChild(text);
                    Renderer.dom.layers.labels.appendChild(labelGroup);
                },

                renderNode: (node, selection) => {
                    const isSwimlane = node.type === 'swimlane';
                    const isText = node.type === 'text';
                    const isIcon = node.type.startsWith('icon-');
                    const targetLayer = isSwimlane ? Renderer.dom.layers.swimlanes : Renderer.dom.layers.nodes;
                    const isSelected = selection.includes(node.id);

                    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    g.setAttribute('class', `node-group ${isSelected ? 'selected' : ''} ${isText ? 'text-node' : ''}`);
                    g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                    g.dataset.id = node.id;

                    // 1. Shape Body
                    const shape = Renderer.createNodeShape(node);
                    if (shape) g.appendChild(shape);

                    // 2. Text / Label
                    Renderer.appendNodeLabel(g, node);

                    // 3. Ports
                    if (!isSwimlane && !isText && !isIcon) {
                        Renderer.appendNodePorts(g, node);
                    }

                    // 4. Resize Handle
                    if (isSelected && selection.length === 1 && !isText) {
                        const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        handle.setAttribute('class', 'resize-handle'); handle.setAttribute('x', node.w - 5); handle.setAttribute('y', node.h - 5);
                        handle.addEventListener('mousedown', (e) => { e.stopPropagation(); Events.startResizeDrag(e, node); });
                        g.appendChild(handle);
                    }

                    // Events
                    g.addEventListener('mousedown', (e) => {
                        if (e.target.classList.contains('port') || e.target.classList.contains('resize-handle')) return;
                        Events.handleSelection(e, node.id); Events.startNodeDrag(e); e.stopPropagation();
                    });
                    g.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        const newLabel = prompt('ラベル編集:', node.label);
                        if (newLabel !== null) { node.label = newLabel.replace(/\\n/g, '\n'); State.saveHistory(); Renderer.render(); Renderer.updatePropsPanel(); }
                    });

                    targetLayer.appendChild(g);
                },

                createNodeShape: (node) => {
                    const isSwimlane = node.type === 'swimlane';
                    const isText = node.type === 'text';
                    const isIcon = node.type.startsWith('icon-');
                    let shape = null;

                    if (isIcon) {
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        let iconPath = '';
                        const color = node.bgColor === '#ffffff' ? '#334155' : node.bgColor;
                        if (node.type === 'icon-pc') iconPath = `<path d="M20 17.575V4H4V17.575H20ZM22 2V19H13V21H16V23H8V21H11V19H2V2H22ZM6 6H18V15.5H6V6Z" fill="${color}"/><rect x="6" y="6" width="12" height="9.5" fill="${color}"/>`;
                        else if (node.type === 'icon-doc') iconPath = `<path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2ZM13 9V3.5L18.5 9H13Z" fill="${color}"/>`;
                        else if (node.type === 'icon-server') iconPath = `<path d="M2 20V4H22V20H2ZM4 6V10H20V6H4ZM4 12V18H20V12H4ZM6 7V9H8V7H6ZM6 13V15H8V13H6Z" fill="${color}"/>`;
                        else if (node.type === 'icon-user') iconPath = `<path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z" fill="${color}"/>`;
                        const scaleX = node.w / 24; const scaleY = node.h / 24;
                        shape.innerHTML = iconPath;
                        shape.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);
                        const hit = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        hit.setAttribute('width', 24); hit.setAttribute('height', 24); hit.setAttribute('fill', 'transparent');
                        shape.appendChild(hit);
                    } else if (node.type === 'circle') {
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        shape.setAttribute('cx', node.w / 2); shape.setAttribute('cy', node.h / 2); shape.setAttribute('r', Math.min(node.w, node.h) / 2);
                    } else if (node.type === 'diamond') {
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                        const w = node.w, h = node.h;
                        shape.setAttribute('points', `${w / 2},0 ${w},${h / 2} ${w / 2},${h} 0,${h / 2}`);
                    } else if (node.type === 'db') {
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const w = node.w, h = node.h; const ry = h * 0.15;
                        shape.setAttribute('d', `M 0 ${ry} A ${w / 2} ${ry} 0 1 1 ${w} ${ry} A ${w / 2} ${ry} 0 1 1 0 ${ry} z M 0 ${ry} L 0 ${h - ry} A ${w / 2} ${ry} 0 0 0 ${w} ${h - ry} L ${w} ${ry} A ${w / 2} ${ry} 0 0 1 0 ${ry}`);
                        shape.setAttribute('fill-rule', 'evenodd');
                    } else if (isText) {
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        shape.setAttribute('width', node.w); shape.setAttribute('height', node.h);
                        shape.setAttribute('fill', 'transparent'); shape.setAttribute('stroke', 'none');
                    } else {
                        // Rect or Swimlane
                        shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        shape.setAttribute('width', node.w); shape.setAttribute('height', node.h);
                        shape.setAttribute('rx', node.type === 'rect' ? 6 : 0);
                    }

                    if (shape && !isText && !isIcon) {
                        shape.setAttribute('class', 'node-body');
                        const sw = node.strokeWidth !== undefined ? node.strokeWidth : 2;
                        shape.setAttribute('stroke-width', sw);
                        if (sw === 0) shape.setAttribute('stroke', 'none');
                        if (isSwimlane) {
                            shape.setAttribute('stroke-dasharray', '5 5');
                            shape.setAttribute('fill', node.bgColor || '#f8fafc');
                            shape.setAttribute('fill-opacity', (!node.bgColor || node.bgColor === '#ffffff') ? '0.5' : '1');
                        } else {
                            shape.setAttribute('fill', node.bgColor || '#ffffff');
                        }
                    }
                    return shape;
                },

                appendNodeLabel: (g, node) => {
                    const isSwimlane = node.type === 'swimlane';
                    const isText = node.type === 'text';
                    const isIcon = node.type.startsWith('icon-');
                    let textX = node.w / 2; let textY = isSwimlane ? 20 : node.h / 2; let anchor = 'middle';
                    if (isIcon) { textY = node.h + 10; }
                    if (isText) { textX = 0; textY = node.h / 2; anchor = 'start'; }

                    if (node.label) {
                        if (node.textBgColor && node.textBgColor !== 'transparent' && !isIcon) {
                            const lines = node.label.split('\n'); const fs = node.fontSize || 14;
                            const maxLineLen = Math.max(...lines.map(l => l.length));
                            const tw = Math.max(20, maxLineLen * (fs * 0.7) + 10);
                            const th = lines.length * (fs * 1.3) + 4;
                            const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                            bg.setAttribute('class', 'text-bg-rect'); bg.setAttribute('fill', node.textBgColor);
                            let bgX = textX - tw / 2; let bgY = textY - th / 2;
                            if (anchor === 'start') bgX = textX - 2;
                            if (isSwimlane) bgY = textY - fs;
                            else bgY = textY - (lines.length * (fs * 1.2)) / 2;
                            bg.setAttribute('x', bgX); bg.setAttribute('y', bgY); bg.setAttribute('width', tw); bg.setAttribute('height', th);
                            g.appendChild(bg);
                        }
                        const text = Utils.createMultilineText(node.label, textX, textY, isSwimlane, node.fontSize, node.textColor, isText);
                        text.setAttribute('class', 'node-label'); text.setAttribute('text-anchor', anchor);
                        if (isSwimlane) text.style.fontWeight = 'bold';
                        g.appendChild(text);
                    }
                },

                appendNodePorts: (g, node) => {
                    const dirs = ['top-L', 'top', 'top-R', 'right-L', 'right', 'right-R', 'bottom-L', 'bottom', 'bottom-R', 'left-L', 'left', 'left-R'];
                    dirs.forEach(dirStr => {
                        const p = PathRouter.getPortPos(node, dirStr);
                        const relX = p.x - node.x; const relY = p.y - node.y;
                        const port = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        port.setAttribute('class', 'port'); port.setAttribute('cx', relX); port.setAttribute('cy', relY);
                        port.addEventListener('mousedown', (e) => { e.stopPropagation(); Events.startConnectionDrag(e, node, { x: relX, y: relY, dir: dirStr }); });
                        if (!dirStr.includes('-')) {
                            port.addEventListener('contextmenu', (e) => { e.preventDefault(); e.stopPropagation(); Events.showQuickAddMenu(e, node, { dir: dirStr }); });
                        }
                        port.dataset.nodeId = node.id; port.dataset.dir = dirStr;
                        g.appendChild(port);
                    });
                },

                renderQuickAddHandles: (node) => {
                    const padding = 20;
                    const handles = [
                        { dir: 'top', x: node.x + node.w / 2, y: node.y - padding },
                        { dir: 'bottom', x: node.x + node.w / 2, y: node.y + node.h + padding },
                        { dir: 'left', x: node.x - padding, y: node.y + node.h / 2 },
                        { dir: 'right', x: node.x + node.w + padding, y: node.y + node.h / 2 }
                    ];
                    handles.forEach(h => {
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('class', 'quick-add-group'); g.style.cursor = 'pointer';
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('class', 'quick-add-handle'); circle.setAttribute('cx', h.x); circle.setAttribute('cy', h.y); circle.setAttribute('r', 8);
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('class', 'quick-add-symbol'); path.setAttribute('d', `M ${h.x - 4} ${h.y} L ${h.x + 4} ${h.y} M ${h.x} ${h.y - 4} L ${h.x} ${h.y + 4}`);
                        g.appendChild(circle); g.appendChild(path);
                        g.addEventListener('mousedown', (e) => { e.stopPropagation(); Events.showQuickAddMenu(e, node, { dir: h.dir }, true); });
                        Renderer.dom.layers.ui.appendChild(g);
                    });
                },

                updatePropsPanel: () => {
                    const p = Renderer.dom.propsPanel;
                    const sel = State.data.selection;
                    if (sel.length === 0) {
                        p.empty.style.display = 'block'; p.multi.style.display = 'none'; p.content.style.display = 'none';
                    } else if (sel.length > 1) {
                        p.empty.style.display = 'none'; p.multi.style.display = 'block'; p.content.style.display = 'none';
                    } else {
                        p.empty.style.display = 'none'; p.multi.style.display = 'none'; p.content.style.display = 'block';
                        const id = sel[0];
                        const node = State.data.nodes.find(n => n.id === id);
                        const edge = State.data.edges.find(e => e.id === id);
                        const el = node || edge;
                        if (el) {
                            p.inputs.id.value = el.id;
                            p.inputs.label.value = el.label || '';
                            p.inputs.fontSize.value = el.fontSize || 14;
                            p.inputs.textColor.value = el.textColor || '#000000';
                            p.inputs.textBgColor.value = (el.textBgColor && el.textBgColor !== 'transparent') ? el.textBgColor : '#ffffff';
                            if (node) {
                                p.groups.nodeType.style.display = 'block'; p.groups.edge.style.display = 'none';
                                p.groups.dim.style.display = 'block'; p.groups.style.style.display = 'block';
                                p.inputs.type.value = node.type;
                                p.inputs.w.value = node.w; p.inputs.h.value = node.h;
                                p.inputs.color.value = node.bgColor || '#ffffff';
                                p.inputs.strokeWidth.value = node.strokeWidth !== undefined ? node.strokeWidth : 2;
                            } else if (edge) {
                                p.groups.nodeType.style.display = 'none'; p.groups.dim.style.display = 'none';
                                p.groups.style.style.display = 'none'; p.groups.edge.style.display = 'block';
                                p.inputs.edgeMarker.value = edge.marker || 'end';
                            }
                        }
                    }
                },

                updateLayerPanel: () => {
                    const list = Renderer.dom.layerList;
                    if (!list) return;
                    list.innerHTML = '';
                    const indexedNodes = State.data.nodes.map((n, i) => ({ ...n, _idx: i }));
                    const reversed = indexedNodes.reverse();
                    reversed.forEach((node) => {
                        const li = document.createElement('li');
                        li.className = 'layer-item'; li.draggable = true; li.dataset.id = node.id;
                        let iconChar = '⬜';
                        if (node.type === 'circle') iconChar = '⚪'; if (node.type === 'diamond') iconChar = '◇'; if (node.type === 'db') iconChar = '🛢️'; if (node.type === 'swimlane') iconChar = '☰'; if (node.type === 'text') iconChar = 'T';
                        if (node.type.startsWith('icon-')) iconChar = '🖼️';
                        const label = node.label ? node.label.replace(/\n/g, ' ') : `(No Label)`;
                        li.innerHTML = `<div class="layer-item-content"><span class="layer-icon">${iconChar}</span><span class="layer-name">${label}</span></div><span class="layer-handle">☰</span>`;
                        li.addEventListener('dragstart', (e) => { State.data.layerDragIdx = node._idx; li.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move'; });
                        li.addEventListener('dragend', () => { li.classList.remove('dragging'); State.data.layerDragIdx = null; });
                        li.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; });
                        li.addEventListener('drop', (e) => {
                            e.preventDefault();
                            const fromIdx = State.data.layerDragIdx; const toIdx = node._idx;
                            if (fromIdx !== null && fromIdx !== toIdx) {
                                const movedNode = State.data.nodes[fromIdx];
                                State.data.nodes.splice(fromIdx, 1); State.data.nodes.splice(toIdx, 0, movedNode);
                                State.saveHistory(); Renderer.render();
                            }
                        });
                        li.addEventListener('click', (e) => { Events.handleSelection(e, node.id); });
                        if (State.data.selection.includes(node.id)) { li.style.borderColor = 'var(--primary-color)'; li.style.backgroundColor = '#f0f9ff'; }
                        list.appendChild(li);
                    });
                },

                updateBtns: () => {
                    if (Renderer.dom.buttons.undo) Renderer.dom.buttons.undo.disabled = State.data.historyIndex <= 0;
                    if (Renderer.dom.buttons.redo) Renderer.dom.buttons.redo.disabled = State.data.historyIndex >= State.data.history.length - 1;
                },

                setZoom: (v) => {
                    State.data.zoom = Math.max(0.2, Math.min(3, v));
                    Renderer.dom.zoomLevel.textContent = Math.round(State.data.zoom * 100) + '%';
                    Renderer.render();
                }
            };

            // --- 6. Events ---
            const Events = {
                init: () => {
                    Events.setupToolbar();
                    Events.setupPropertyInputs();
                    Events.setupCanvasInteractions();
                    Events.setupKeyboard();
                    Events.setupDragAndDrop();
                    Events.setupModal();
                    Events.setupGlobal();
                },

                handleSelection: (e, id) => {
                    if (e.shiftKey || e.ctrlKey) {
                        if (State.data.selection.includes(id)) State.data.selection = State.data.selection.filter(sid => sid !== id);
                        else State.data.selection.push(id);
                    } else {
                        if (State.data.selection.length > 1 && State.data.selection.includes(id)) { } else { State.data.selection = [id]; }
                    }
                    Renderer.render();
                },

                showQuickAddMenu: (e, node, p, fromHandle = false) => {
                    State.data.quickAdd = { visible: true, sourceNodeId: node.id, portDir: p.dir, x: e.clientX, y: e.clientY };
                    const menu = Renderer.dom.quickAddMenu;
                    menu.style.left = e.clientX + 'px'; menu.style.top = e.clientY + 'px'; menu.style.display = 'grid';
                },

                hideQuickAddMenu: () => {
                    Renderer.dom.quickAddMenu.style.display = 'none'; State.data.quickAdd.visible = false;
                },

                startNodeDrag: (e) => {
                    State.data.isDragging = true; State.data.dragTarget = 'node';
                    const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
                    const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
                    State.data.dragStart = { rawX, rawY };
                    State.data.dragItemOffset = {};
                    State.data.selection.forEach(id => {
                        const n = State.data.nodes.find(node => node.id === id);
                        if (n) State.data.dragItemOffset[id] = { x: n.x, y: n.y };
                    });
                    const selectedNodeIds = new Set(State.data.selection);
                    State.data.edges.forEach(edge => {
                        if (selectedNodeIds.has(edge.source) && selectedNodeIds.has(edge.target) && edge.waypoints) {
                            State.data.dragItemOffset[`edge-wp-${edge.id}`] = JSON.parse(JSON.stringify(edge.waypoints));
                        }
                    });
                },

                startResizeDrag: (e, node) => {
                    State.data.isDragging = true; State.data.dragTarget = 'resize';
                    const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
                    const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
                    State.data.dragStart = { rawX, rawY };
                    State.data.dragItemOffset = { w: node.w, h: node.h, id: node.id };
                },

                startConnectionDrag: (e, sourceNode, portConfig) => {
                    State.data.isDragging = true; State.data.dragTarget = 'port';
                    State.data.dragStart = { nodeId: sourceNode.id, portDir: portConfig.dir, x: sourceNode.x + portConfig.x, y: sourceNode.y + portConfig.y };
                    State.data.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    State.data.tempLine.setAttribute('stroke', '#3b82f6'); State.data.tempLine.setAttribute('stroke-width', '2'); State.data.tempLine.setAttribute('stroke-dasharray', '4 4');
                    const sx = State.data.dragStart.x, sy = State.data.dragStart.y;
                    State.data.tempLine.setAttribute('x1', sx); State.data.tempLine.setAttribute('y1', sy); State.data.tempLine.setAttribute('x2', sx); State.data.tempLine.setAttribute('y2', sy);
                    Renderer.dom.layers.ui.appendChild(State.data.tempLine);
                },

                startPan: (e) => {
                    State.data.isDragging = true; State.data.dragTarget = 'pan';
                    const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
                    const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
                    State.data.dragStart = { rawX, rawY };
                    State.data.dragItemOffset = { ...State.data.pan };
                    document.getElementById('canvas-wrapper').style.cursor = 'grabbing';
                },

                startRubberband: (e) => {
                    State.data.isDragging = true; State.data.dragTarget = 'rubberband';
                    const pos = Utils.getMousePos(e, Renderer.dom.svg, State.data.pan, State.data.zoom);
                    State.data.dragStart = { x: pos.x, y: pos.y };
                    State.data.rubberbandRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    State.data.rubberbandRect.setAttribute('class', 'rubberband');
                    State.data.rubberbandRect.setAttribute('x', pos.x); State.data.rubberbandRect.setAttribute('y', pos.y);
                    Renderer.dom.layers.ui.appendChild(State.data.rubberbandRect);
                    if (!e.shiftKey && !e.ctrlKey) { State.data.selection = []; Renderer.render(); }
                },

                // --- Setup Methods ---
                setupToolbar: () => {
                    document.getElementById('btn-undo').addEventListener('click', State.undo);
                    document.getElementById('btn-redo').addEventListener('click', State.redo);
                    document.getElementById('btn-home').addEventListener('click', () => { State.data.pan = { x: 0, y: 0 }; State.data.zoom = 1; Renderer.setZoom(1); });
                    document.getElementById('btn-clear').addEventListener('click', () => { if (confirm('全てクリアしますか？')) { State.data.nodes = []; State.data.edges = []; State.saveHistory(); Renderer.render(); } });
                    document.getElementById('btn-zoom-in').addEventListener('click', () => Renderer.setZoom(State.data.zoom + 0.1));
                    document.getElementById('btn-zoom-out').addEventListener('click', () => Renderer.setZoom(State.data.zoom - 0.1));
                    document.getElementById('btn-fit').addEventListener('click', () => { State.data.zoom = 1; State.data.pan = { x: 0, y: 0 }; Renderer.setZoom(1); });

                    // Export Menu
                    const btnExportMenu = document.getElementById('btn-export-menu');
                    const exportMenu = document.getElementById('export-menu');
                    btnExportMenu.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const isVisible = exportMenu.style.display === 'flex';
                        if (isVisible) { exportMenu.style.display = 'none'; }
                        else {
                            const rect = btnExportMenu.getBoundingClientRect();
                            exportMenu.style.top = (rect.bottom + 4) + 'px';
                            exportMenu.style.left = (rect.right - 180) + 'px';
                            exportMenu.style.display = 'flex';
                        }
                    });
                    window.addEventListener('click', (e) => {
                        if (!e.target.closest('#btn-export-menu') && !e.target.closest('#export-menu')) exportMenu.style.display = 'none';
                    });
                    document.getElementById('export-json').addEventListener('click', () => {
                        const b = new Blob([JSON.stringify({ nodes: State.data.nodes, edges: State.data.edges }, null, 2)], { type: 'application/json' });
                        const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `bizflow_${Date.now()}.json`; a.click();
                    });
                    document.getElementById('export-pdf').addEventListener('click', () => {
                        if (State.data.nodes.length === 0) return alert('キャンバスが空です');
                        const originalZoom = State.data.zoom; const originalPan = { ...State.data.pan };
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        State.data.nodes.forEach(n => { if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y; if (n.x + n.w > maxX) maxX = n.x + n.w; if (n.y + n.h > maxY) maxY = n.y + n.h; });
                        const padding = 20; State.data.pan.x = -minX + padding; State.data.pan.y = -minY + padding; State.data.zoom = 1;
                        Renderer.render(); setTimeout(() => { window.print(); State.data.pan = originalPan; State.data.zoom = originalZoom; Renderer.render(); }, 100);
                    });
                    const exportImage = (format) => {
                        exportMenu.style.display = 'none';
                        if (State.data.nodes.length === 0) return alert('キャンバスが空です');
                        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
                        State.data.nodes.forEach(n => { if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y; if (n.x + n.w > maxX) maxX = n.x + n.w; if (n.y + n.h > maxY) maxY = n.y + n.h; });
                        const padding = 50; const width = maxX - minX + padding * 2; const height = maxY - minY + padding * 2;
                        const clone = Renderer.dom.svg.cloneNode(true);
                        const viewport = clone.getElementById('viewport-group');
                        viewport.setAttribute('transform', `translate(${padding - minX}, ${padding - minY})`);
                        clone.setAttribute('width', width); clone.setAttribute('height', height);
                        clone.querySelectorAll('.port, .resize-handle, .edge-handle, #layer-ui').forEach(el => el.remove());
                        const isPng = format === 'image/png';
                        const bgColor = isPng ? 'transparent' : '#f0f0f0';
                        clone.style.background = bgColor;
                        const style = document.createElement('style');
                        style.textContent = `.node-body { stroke: #1e293b; vector-effect: non-scaling-stroke; } .connector-path { fill: none; stroke: #64748b; stroke-width: 2px; stroke-linejoin: round; stroke-linecap: round; } .node-label, .edge-label-text { font-family: sans-serif; font-size: 14px; fill: #334155; } .text-bg-rect { fill-opacity: 1; stroke: none; }`;
                        clone.insertBefore(style, clone.firstChild);
                        const svgData = new XMLSerializer().serializeToString(clone);
                        if (format === 'image/svg+xml') {
                            const b = new Blob([svgData], { type: 'image/svg+xml' });
                            const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `bizflow_${Date.now()}.svg`; a.click(); return;
                        }
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d');
                            if (!isPng) { ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.beginPath(); for (let x = 0; x <= width; x += 20) { ctx.moveTo(x, 0); ctx.lineTo(x, height); } for (let y = 0; y <= height; y += 20) { ctx.moveTo(0, y); ctx.lineTo(width, y); } ctx.stroke(); }
                            ctx.drawImage(img, 0, 0);
                            const a = document.createElement('a'); a.href = canvas.toDataURL(format); a.download = `bizflow_${Date.now()}.${isPng ? 'png' : 'jpg'}`; a.click();
                        };
                        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
                    };
                    document.getElementById('export-png').addEventListener('click', () => exportImage('image/png'));
                    document.getElementById('export-jpeg').addEventListener('click', () => exportImage('image/jpeg'));
                    document.getElementById('export-svg').addEventListener('click', () => exportImage('image/svg+xml'));

                    document.getElementById('btn-import').addEventListener('click', () => document.getElementById('file-input').click());
                    document.getElementById('file-input').addEventListener('change', (e) => {
                        const f = e.target.files[0]; if (!f) return;
                        const r = new FileReader(); r.onload = (ev) => { try { const d = JSON.parse(ev.target.result); State.data.nodes = d.nodes; State.data.edges = d.edges; State.data.selection = []; State.saveHistory(); Renderer.render(); } catch (err) { alert('読み込みエラー'); } };
                        r.readAsText(f);
                    });
                },

                setupPropertyInputs: () => {
                    const inputs = Renderer.dom.propsPanel.inputs;
                    inputs.label.addEventListener('input', (e) => State.updateSelectedProps('label', e.target.value));
                    inputs.label.addEventListener('change', State.saveHistory);
                    inputs.type.addEventListener('change', (e) => { State.updateSelectedProps('type', e.target.value); State.saveHistory(); });
                    inputs.fontSize.addEventListener('input', (e) => { State.updateSelectedProps('fontSize', e.target.value, true); State.saveHistory(); });
                    inputs.textColor.addEventListener('input', (e) => { State.updateSelectedProps('textColor', e.target.value); State.saveHistory(); });
                    inputs.textBgColor.addEventListener('input', (e) => { State.updateSelectedProps('textBgColor', e.target.value); State.saveHistory(); });
                    document.getElementById('btn-text-bg-none').addEventListener('click', () => { State.updateSelectedProps('textBgColor', 'transparent'); State.saveHistory(); });
                    inputs.color.addEventListener('input', (e) => { State.updateSelectedProps('bgColor', e.target.value); State.saveHistory(); });
                    inputs.strokeWidth.addEventListener('input', (e) => { State.updateSelectedProps('strokeWidth', e.target.value, true); State.saveHistory(); });
                    document.getElementById('btn-reset-color').addEventListener('click', () => { State.updateSelectedProps('bgColor', '#ffffff'); inputs.color.value = '#ffffff'; State.saveHistory(); });
                    inputs.edgeMarker.addEventListener('change', (e) => { State.updateSelectedProps('marker', e.target.value); State.saveHistory(); });
                    inputs.w.addEventListener('input', (e) => {
                        if (State.data.selection.length === 1) { const n = State.data.nodes.find(x => x.id === State.data.selection[0]); if (n) { n.w = Math.max(CONFIG.MIN_SIZE, Utils.snap(parseInt(e.target.value))); Renderer.render(); State.saveHistory(); } }
                    });
                    inputs.h.addEventListener('input', (e) => {
                        if (State.data.selection.length === 1) { const n = State.data.nodes.find(x => x.id === State.data.selection[0]); if (n) { n.h = Math.max(CONFIG.MIN_SIZE, Utils.snap(parseInt(e.target.value))); Renderer.render(); State.saveHistory(); } }
                    });
                    document.querySelectorAll('.color-swatch').forEach(swatch => {
                        swatch.addEventListener('click', () => {
                            const color = swatch.dataset.color;
                            State.updateSelectedProps('bgColor', color);
                            inputs.color.value = color;
                            State.saveHistory();
                        });
                    });
                },

                setupCanvasInteractions: () => {
                    const { svg } = Renderer.dom;
                    window.addEventListener('mousemove', (e) => {
                        if (!State.data.isDragging) return;
                        const mousePos = Utils.getMousePos(e, svg, State.data.pan, State.data.zoom);
                        const mouseX = mousePos.x; const mouseY = mousePos.y;

                        if (State.data.dragTarget === 'node') {
                            const deltaX = (e.clientX - State.data.dragStart.rawX) / State.data.zoom;
                            const deltaY = (e.clientY - State.data.dragStart.rawY) / State.data.zoom;
                            State.data.selection.forEach(id => {
                                const node = State.data.nodes.find(n => n.id === id);
                                if (node && State.data.dragItemOffset[id]) {
                                    node.x = Utils.snap(State.data.dragItemOffset[id].x + deltaX);
                                    node.y = Utils.snap(State.data.dragItemOffset[id].y + deltaY);
                                }
                            });
                            Object.keys(State.data.dragItemOffset).forEach(key => {
                                if (key.startsWith('edge-wp-')) {
                                    const edgeId = key.replace('edge-wp-', '');
                                    const edge = State.data.edges.find(e => e.id === edgeId);
                                    const initialWPs = State.data.dragItemOffset[key];
                                    if (edge && initialWPs) {
                                        edge.waypoints = initialWPs.map(wp => ({ x: Utils.snap(wp.x + deltaX), y: Utils.snap(wp.y + deltaY) }));
                                    }
                                }
                            });
                            requestAnimationFrame(Renderer.render);
                        } else if (State.data.dragTarget === 'resize') {
                            const node = State.data.nodes.find(n => n.id === State.data.dragItemOffset.id);
                            if (node) {
                                const deltaX = (e.clientX - State.data.dragStart.rawX) / State.data.zoom;
                                const deltaY = (e.clientY - State.data.dragStart.rawY) / State.data.zoom;
                                node.w = Math.max(CONFIG.MIN_SIZE, Utils.snap(State.data.dragItemOffset.w + deltaX));
                                node.h = Math.max(CONFIG.MIN_SIZE, Utils.snap(State.data.dragItemOffset.h + deltaY));
                                requestAnimationFrame(Renderer.render);
                            }
                        } else if (State.data.dragTarget === 'port') {
                            State.data.tempLine.setAttribute('x2', mouseX); State.data.tempLine.setAttribute('y2', mouseY);
                        } else if (State.data.dragTarget === 'edge-handle') {
                            const edge = State.data.edges.find(e => e.id === State.data.draggingHandle.edgeId);
                            if (edge && edge.waypoints) {
                                const wp = edge.waypoints[State.data.draggingHandle.index];
                                if (wp) { wp.x = Utils.snap(mouseX); wp.y = Utils.snap(mouseY); requestAnimationFrame(Renderer.render); }
                            }
                        } else if (State.data.dragTarget === 'pan') {
                            const dx = e.clientX - State.data.dragStart.rawX; const dy = e.clientY - State.data.dragStart.rawY;
                            State.data.pan.x = State.data.dragItemOffset.x + dx; State.data.pan.y = State.data.dragItemOffset.y + dy;
                            requestAnimationFrame(Renderer.render);
                        } else if (State.data.dragTarget === 'rubberband') {
                            const x = Math.min(State.data.dragStart.x, mouseX); const y = Math.min(State.data.dragStart.y, mouseY);
                            const w = Math.abs(mouseX - State.data.dragStart.x); const h = Math.abs(mouseY - State.data.dragStart.y);
                            State.data.rubberbandRect.setAttribute('x', x); State.data.rubberbandRect.setAttribute('y', y);
                            State.data.rubberbandRect.setAttribute('width', w); State.data.rubberbandRect.setAttribute('height', h);
                        }
                    });

                    svg.addEventListener('mousedown', (e) => {
                        if (State.data.quickAdd.visible) Events.hideQuickAddMenu();
                        if (e.button === 0) {
                            if (e.code === 'Space' || e.button === 1) Events.startPan(e);
                            else if (e.target.id === 'main-svg' || e.target.id === 'bg-rect') Events.startRubberband(e);
                        }
                    });

                    window.addEventListener('mouseup', (e) => {
                        if (!State.data.isDragging) return;
                        if (State.data.dragTarget === 'port') {
                            State.data.tempLine.remove();
                            const el = document.elementFromPoint(e.clientX, e.clientY);
                            if (el && el.classList.contains('port')) {
                                const tId = el.dataset.nodeId; const tDir = el.dataset.dir;
                                if (tId && tId !== State.data.dragStart.nodeId) {
                                    State.data.edges.push({ id: Utils.uuid(), source: State.data.dragStart.nodeId, sourcePort: State.data.dragStart.portDir, target: tId, targetPort: tDir, label: '', marker: 'end' });
                                    State.saveHistory();
                                }
                            }
                        } else if (State.data.dragTarget === 'rubberband') {
                            const r = State.data.rubberbandRect;
                            const rx = parseFloat(r.getAttribute('x')); const ry = parseFloat(r.getAttribute('y'));
                            const rw = parseFloat(r.getAttribute('width')); const rh = parseFloat(r.getAttribute('height'));
                            State.data.nodes.forEach(n => {
                                if (n.x < rx + rw && n.x + n.w > rx && n.y < ry + rh && n.y + n.h > ry) { if (!State.data.selection.includes(n.id)) State.data.selection.push(n.id); }
                            });
                            State.data.rubberbandRect.remove(); Renderer.updatePropsPanel();
                        } else if (['node', 'resize', 'edge-handle'].includes(State.data.dragTarget)) { State.saveHistory(); }
                        if (State.data.dragTarget === 'pan') document.getElementById('canvas-wrapper').style.cursor = 'default';
                        State.data.isDragging = false; State.data.dragTarget = null; Renderer.render();
                    });

                    const wrapperEl = document.getElementById('canvas-wrapper');
                    wrapperEl.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        if (e.ctrlKey) { const delta = e.deltaY > 0 ? -0.05 : 0.05; Renderer.setZoom(State.data.zoom + delta); }
                        else {
                            let dx = -e.deltaX; let dy = -e.deltaY;
                            if (dx === 0 && e.shiftKey) { dx = -e.deltaY; dy = 0; }
                            State.data.pan.x += dx; State.data.pan.y += dy; Renderer.render();
                        }
                    }, { passive: false });
                },

                setupKeyboard: () => {
                    window.addEventListener('keydown', (e) => {
                        const activeTag = document.activeElement ? document.activeElement.tagName.toUpperCase() : '';
                        const isInput = (activeTag === 'INPUT' || activeTag === 'TEXTAREA');
                        if (e.code === 'Space' && !isInput) document.getElementById('canvas-wrapper').style.cursor = 'grab';
                        if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !isInput) {
                            e.preventDefault(); State.data.selection = [...State.data.nodes.map(n => n.id), ...State.data.edges.map(e => e.id)]; Renderer.render(); Renderer.updatePropsPanel();
                        }
                        if ((e.key === 'Delete' || e.key === 'Backspace') && !isInput && State.data.selection.length > 0) {
                            State.data.nodes = State.data.nodes.filter(n => !State.data.selection.includes(n.id));
                            State.data.edges = State.data.edges.filter(edge => !State.data.selection.includes(edge.id) && !State.data.selection.includes(edge.source) && !State.data.selection.includes(edge.target));
                            State.data.selection = []; State.saveHistory(); Renderer.render(); Renderer.updatePropsPanel();
                        }
                        if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !isInput) {
                            if (State.data.selection.length > 0) {
                                const n = State.data.nodes.filter(n => State.data.selection.includes(n.id));
                                const e = State.data.edges.filter(e => State.data.selection.includes(e.source) && State.data.selection.includes(e.target));
                                State.data.clipboard = JSON.parse(JSON.stringify({ nodes: n, edges: e }));
                                Utils.showToast('コピーしました');
                            }
                        }
                        if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !isInput) {
                            if (State.data.clipboard) {
                                const idMap = {}; const off = 20; const nn = []; const ne = []; const ns = [];
                                State.data.clipboard.nodes.forEach(n => {
                                    const nid = Utils.uuid(); idMap[n.id] = nid;
                                    nn.push({ ...n, id: nid, x: n.x + off, y: n.y + off }); ns.push(nid);
                                });
                                State.data.clipboard.edges.forEach(e => {
                                    if (idMap[e.source] && idMap[e.target]) ne.push({ ...e, id: Utils.uuid(), source: idMap[e.source], target: idMap[e.target] });
                                });
                                State.data.nodes.push(...nn); State.data.edges.push(...ne); State.data.selection = ns; State.saveHistory(); Renderer.render(); Utils.showToast('貼り付けました');
                            }
                        }
                        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !isInput) { e.preventDefault(); State.undo(); }
                        if ((e.ctrlKey || e.metaKey) && e.key === 'y' && !isInput) { e.preventDefault(); State.redo(); }
                    });
                    window.addEventListener('keyup', (e) => { if (e.code === 'Space') document.getElementById('canvas-wrapper').style.cursor = 'default'; });
                },

                setupDragAndDrop: () => {
                    const dndItems = document.querySelectorAll('.dnd-item');
                    dndItems.forEach(item => item.addEventListener('dragstart', (e) => e.dataTransfer.setData('type', item.dataset.type)));
                    const wrapper = document.getElementById('canvas-wrapper');
                    wrapper.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
                    wrapper.addEventListener('drop', (e) => {
                        e.preventDefault(); const type = e.dataTransfer.getData('type'); if (!type) return;
                        const pos = Utils.getMousePos(e, Renderer.dom.svg, State.data.pan, State.data.zoom);
                        let w = 120, h = 60, lbl = '処理', bg = '#ffffff', strokeW = 2;
                        if (type === 'circle') { w = 60; h = 60; lbl = '開始'; }
                        else if (type === 'diamond') { w = 80; h = 80; lbl = '?'; }
                        else if (type === 'db') { w = 60; h = 60; lbl = 'DB'; }
                        else if (type === 'swimlane') { w = 300; h = 400; lbl = '担当領域'; bg = '#f8fafc'; strokeW = 0.5; }
                        else if (type === 'text') { w = 120; h = 40; lbl = 'テキスト'; bg = 'transparent'; }
                        else if (type.startsWith('icon-')) { w = 48; h = 48; lbl = ''; bg = '#334155'; }
                        if (type === 'icon-pc') lbl = '端末';
                        if (type === 'icon-doc') lbl = '資料';
                        if (type === 'icon-server') lbl = 'サーバー';
                        if (type === 'icon-user') lbl = 'ユーザー';
                        const newNode = { id: Utils.uuid(), type: type, x: Utils.snap(pos.x - w / 2), y: Utils.snap(pos.y - h / 2), w: w, h: h, label: lbl, bgColor: bg, strokeWidth: strokeW };
                        State.data.nodes.push(newNode); State.saveHistory(); State.data.selection = [newNode.id]; Renderer.render();
                    });
                },

                setupModal: () => {
                    const modal = document.getElementById('ai-prompt-modal');
                    document.getElementById('btn-ai-prompt').addEventListener('click', () => { modal.style.display = 'flex'; });
                    document.getElementById('btn-close-modal').addEventListener('click', () => { modal.style.display = 'none'; });
                    document.getElementById('btn-copy-prompt').addEventListener('click', () => {
                        const textarea = document.getElementById('ai-prompt-text'); textarea.select();
                        document.execCommand('copy'); Utils.showToast('コピーしました');
                    });
                    document.getElementById('btn-reset-prompt').addEventListener('click', () => {
                        document.getElementById('ai-prompt-text').value = CONFIG.DEFAULT_AI_PROMPT_TEXT;
                        Utils.showToast('初期文に戻しました');
                    });
                    modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });
                },

                setupGlobal: () => {
                    document.querySelectorAll('.tab-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                            document.querySelectorAll('.panel-content').forEach(p => p.classList.remove('active'));
                            btn.classList.add('active');
                            const tabId = `tab-${btn.dataset.tab}`;
                            document.getElementById(tabId).classList.add('active');
                            State.data.activeTab = btn.dataset.tab;
                            if (State.data.activeTab === 'layer') Renderer.updateLayerPanel();
                        });
                    });

                    document.querySelectorAll('.quick-add-item').forEach(item => {
                        item.addEventListener('click', (e) => {
                            if (!State.data.quickAdd.visible) return;
                            const type = item.dataset.type;
                            const sourceNode = State.data.nodes.find(n => n.id === State.data.quickAdd.sourceNodeId);
                            if (!sourceNode) return;
                            let w = 120, h = 60, lbl = '処理';
                            if (type === 'circle') { w = 60; h = 60; lbl = '終了'; }
                            if (type === 'diamond') { w = 80; h = 80; lbl = '?'; }
                            if (type === 'db') { w = 60; h = 60; lbl = 'DB'; }
                            const offset = 80;
                            let nx = sourceNode.x, ny = sourceNode.y;
                            const dir = State.data.quickAdd.portDir ? State.data.quickAdd.portDir.split('-')[0] : 'bottom';
                            if (dir === 'top') { nx += (sourceNode.w - w) / 2; ny -= (h + offset); }
                            if (dir === 'bottom') { nx += (sourceNode.w - w) / 2; ny += (sourceNode.h + offset); }
                            if (dir === 'left') { nx -= (w + offset); ny += (sourceNode.h - h) / 2; }
                            if (dir === 'right') { nx += (sourceNode.w + offset); ny += (sourceNode.h - h) / 2; }
                            const newNode = { id: Utils.uuid(), type: type, x: Utils.snap(nx), y: Utils.snap(ny), w: w, h: h, label: lbl, bgColor: '#ffffff', strokeWidth: 2 };
                            let targetDir = 'top';
                            if (dir === 'top') targetDir = 'bottom'; if (dir === 'bottom') targetDir = 'top'; if (dir === 'left') targetDir = 'right'; if (dir === 'right') targetDir = 'left';
                            State.data.nodes.push(newNode);
                            State.data.edges.push({ id: Utils.uuid(), source: sourceNode.id, sourcePort: State.data.quickAdd.portDir, target: newNode.id, targetPort: targetDir, label: '' });
                            State.data.selection = [newNode.id];
                            State.saveHistory(); Renderer.render(); Events.hideQuickAddMenu();
                        });
                    });
                }
            };

            // --- 7. Main ---
            document.addEventListener('DOMContentLoaded', () => {
                Renderer.init();
                Events.init();
                // Load Initial State
                try {
                    const s = localStorage.getItem(CONFIG.STORAGE_KEY);
                    if (s) {
                        State.data.history.push(s);
                        State.data.historyIndex = 0;
                        State.restore(s);
                    } else {
                        State.saveHistory();
                    }
                } catch (e) {
                    console.error('Storage Error', e);
                    State.saveHistory();
                }
                Renderer.render();
            });

        })();
    </script>
</body>

</html>
