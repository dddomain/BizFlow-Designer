<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BizFlow Designer (v6.1)</title>
    <style>
        /* =========================================
           CSS Reset & Variables
           ========================================= */
        :root {
            --bg-color: #f0f0f0;
            --panel-bg: #ffffff;
            --border-color: #e2e8f0;
            --text-main: #334155;
            --text-muted: #64748b;
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --grid-color: #cbd5e1;
            --selection-color: #3b82f6;
            --drag-placeholder: #eff6ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Yu Gothic UI', 'Meiryo', sans-serif;
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-color);
            user-select: none;
            touch-action: none;
            /* „Éñ„É©„Ç¶„Ç∂Ê®ôÊ∫ñ„ÅÆ„Çø„ÉÉ„ÉÅÊìç‰Ωú„ÇíÁÑ°ÂäπÂåñ */
        }

        /* =========================================
           Layout
           ========================================= */
        .app-container {
            display: grid;
            grid-template-columns: 240px 1fr 280px;
            height: 100%;
            width: 100%;
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .h-full {
            height: 100%;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        .items-center {
            align-items: center;
        }

        .gap-2 {
            gap: 0.5rem;
        }

        .p-4 {
            padding: 1rem;
        }

        .border-b {
            border-bottom: 1px solid var(--border-color);
        }

        .border-r {
            border-right: 1px solid var(--border-color);
        }

        .border-l {
            border-left: 1px solid var(--border-color);
        }

        .border-t {
            border-top: 1px solid var(--border-color);
        }

        /* =========================================
           Left Panel (Stencil)
           ========================================= */
        .panel-header {
            background-color: #f8fafc;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .app-title {
            font-size: 1.125rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .app-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .stencil-content {
            overflow-y: auto;
            flex: 1;
            padding: 1rem;
            background: var(--panel-bg);
            min-height: 0;
        }

        .group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            margin-top: 1rem;
        }

        .group-title:first-child {
            margin-top: 0;
        }

        .dnd-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            background: white;
            cursor: grab;
            transition: all 0.2s;
            margin-bottom: 0.75rem;
        }

        .dnd-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-color);
        }

        .dnd-item:active {
            cursor: grabbing;
        }

        .shape-preview {
            border: 2px solid #1e293b;
            background: white;
            box-sizing: border-box;
        }

        .shape-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }

        .shape-rect {
            width: 64px;
            height: 40px;
            border-radius: 6px;
        }

        .shape-diamond {
            width: 40px;
            height: 40px;
            transform: rotate(45deg) scale(0.8);
            margin: 4px;
        }

        .svg-icon-container {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .svg-icon-container svg {
            width: 100%;
            height: 100%;
            overflow: visible;
        }

        .shape-swimlane {
            width: 64px;
            height: 48px;
            border: 2px solid #1e293b;
            border-top-width: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .swimlane-line {
            width: 100%;
            height: 1px;
            background: #cbd5e1;
        }

        .shape-text {
            width: 64px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px dashed #cbd5e1;
            background: transparent;
            font-size: 20px;
            font-weight: bold;
            color: #1e293b;
        }

        .item-label {
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 0.5rem;
        }

        /* =========================================
           Center Panel (Canvas)
           ========================================= */
        .toolbar {
            height: 48px;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            z-index: 10;
            position: relative;
            flex-shrink: 0;
        }

        .btn-icon {
            background: none;
            border: none;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-icon:hover:not(:disabled) {
            background-color: #f1f5f9;
        }

        .btn-icon:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-icon svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .separator {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 0.5rem;
        }

        .btn-text {
            padding: 6px 12px;
            font-size: 0.875rem;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            position: relative;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary {
            color: var(--text-main);
            border-color: var(--border-color);
            background: white;
        }

        .btn-secondary:hover {
            background-color: #f8fafc;
        }

        .btn-danger {
            color: #dc2626;
        }

        .btn-danger:hover {
            background-color: #fef2f2;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
            background-color: var(--bg-color);
            overflow: hidden;
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: default;
        }

        svg {
            display: block;
            overflow: visible;
        }

        .node-group {
            cursor: move;
        }

        .node-body {
            stroke: #1e293b;
            vector-effect: non-scaling-stroke;
        }

        .node-label {
            pointer-events: none;
            font-family: sans-serif;
        }

        .edge-label-text {
            font-size: 12px;
            fill: #475569;
            font-family: sans-serif;
        }

        .text-bg-rect {
            fill-opacity: 1;
            stroke: none;
            rx: 2px;
        }

        .connector-path {
            fill: none;
            stroke: #64748b;
            stroke-width: 2px;
            stroke-linejoin: round;
            stroke-linecap: round;
            pointer-events: stroke;
            cursor: pointer;
        }

        .connector-path:hover {
            stroke: var(--primary-color);
            stroke-width: 3px !important;
        }

        .connector-path.selected {
            stroke: var(--primary-color);
            stroke-width: 3px !important;
        }

        .port {
            fill: white;
            stroke: var(--primary-color);
            stroke-width: 1px;
            r: 4px;
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .node-group:hover .port {
            opacity: 1;
        }

        .port:hover {
            fill: var(--primary-color);
            r: 6px;
        }

        .selected .node-body {
            stroke: var(--primary-color);
            stroke-dasharray: 5 5;
        }

        .selected.text-node .node-label {
            fill: var(--primary-color);
            text-decoration: underline;
        }

        .resize-handle {
            width: 10px;
            height: 10px;
            fill: var(--primary-color);
            stroke: white;
            stroke-width: 1px;
            cursor: nwse-resize;
            display: none;
        }

        .node-group.selected .resize-handle {
            display: block;
        }

        .rubberband {
            fill: rgba(59, 130, 246, 0.1);
            stroke: #3b82f6;
            stroke-width: 1px;
            pointer-events: none;
        }

        /* Quick Add Handle */
        .quick-add-handle {
            fill: #fff;
            stroke: var(--primary-color);
            stroke-width: 1px;
            cursor: pointer;
            opacity: 0.9;
            transition: all 0.2s;
        }

        .quick-add-handle:hover {
            fill: var(--primary-color);
            opacity: 1;
        }

        .quick-add-symbol {
            pointer-events: none;
            stroke: var(--primary-color);
            stroke-width: 2px;
            stroke-linecap: round;
        }

        .quick-add-group:hover .quick-add-symbol {
            stroke: white;
        }

        /* =========================================
           Right Panel (Tabs & Content)
           ========================================= */
        .properties-panel {
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background: #f8fafc;
            flex-shrink: 0;
        }

        .tab-btn {
            flex: 1;
            padding: 0.75rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .tab-btn:hover {
            color: var(--primary-color);
            background: #f1f5f9;
        }

        .tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background: white;
        }

        .panel-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            min-height: 0;
        }

        .panel-content.active {
            display: block;
        }

        .prop-group {
            margin-bottom: 1rem;
        }

        .prop-label {
            display: block;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .prop-input {
            width: 100%;
            padding: 0.5rem;
            font-size: 0.875rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            outline: none;
        }

        .prop-input:focus {
            border-color: var(--primary-color);
        }

        .color-picker-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .layer-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .layer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin-bottom: 4px;
            border: 1px solid var(--border-color);
            background: white;
            border-radius: 4px;
            cursor: grab;
            font-size: 0.8rem;
        }

        .layer-item:hover {
            border-color: var(--primary-color);
        }

        .layer-item:active {
            cursor: grabbing;
        }

        .layer-item.dragging {
            opacity: 0.5;
            background: var(--drag-placeholder);
        }

        .layer-item-content {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            overflow: hidden;
        }

        .layer-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .layer-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-handle {
            color: #cbd5e1;
            cursor: grab;
        }

        #quick-add-menu {
            position: absolute;
            background: white;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            padding: 8px;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            z-index: 100;
        }

        .quick-add-item {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .quick-add-item:hover {
            background-color: #f1f5f9;
            border-color: var(--primary-color);
        }

        #export-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: white;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            width: 180px;
            display: none;
            flex-direction: column;
            z-index: 100;
        }

        .export-item {
            padding: 8px 12px;
            text-align: left;
            font-size: 0.875rem;
            color: var(--text-main);
            background: none;
            border: none;
            cursor: pointer;
        }

        .export-item:hover {
            background-color: #f1f5f9;
        }

        #toast {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: #1e293b;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.875rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 200;
        }

        /* Print */
        @media print {
            @page {
                size: auto;
                margin: 0mm;
            }

            body {
                background: white;
                overflow: visible;
                margin: 0;
                padding: 0;
            }

            .app-container {
                display: block;
                height: auto;
                width: 100%;
            }

            .flex-col.border-r,
            .properties-panel,
            .toolbar,
            #toast,
            #quick-add-menu,
            #export-menu {
                display: none !important;
            }

            #canvas-wrapper {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                overflow: visible;
                background: none;
                border: none;
                margin: 0;
            }

            svg#main-svg {
                width: 100%;
                height: 100%;
                overflow: visible;
                background-color: white;
            }

            #bg-rect {
                fill: white !important;
            }

            pattern#grid-pattern path {
                stroke: none !important;
            }

            .port,
            .resize-handle,
            .rubberband,
            #layer-ui {
                display: none !important;
            }
        }
    </style>
</head>

<body>

    <div class="app-container">
        <!-- LEFT PANEL -->
        <div class="flex flex-col border-r shadow-sm z-10 h-full overflow-hidden">
            <div class="panel-header">
                <div class="app-title">
                    <svg width="24" height="24" viewBox="0 0 256 256" fill="#3b82f6">
                        <path
                            d="M200,168a32,32,0,0,0-30.37,22.18L130.3,109.84a8,8,0,0,0-12.6,0l-39.33,80.34A32,32,0,1,0,88,200a31.86,31.86,0,0,0-2.34-12l35.8-73.13,35.8,73.13A31.86,31.86,0,0,0,152,200a32,32,0,1,0,48-32Zm-144,48a16,16,0,1,1,16-16A16,16,0,0,1,56,216Zm96,0a16,16,0,1,1,16-16A16,16,0,0,1,152,216Zm48,0a16,16,0,1,1,16-16A16,16,0,0,1,200,216ZM96,64A32,32,0,1,1,64,32,32,32,0,0,1,96,64Zm8,53.48-18.1-37A47.85,47.85,0,0,0,128,112a47.85,47.85,0,0,0,42.1-31.54l-18.1,37A32,32,0,0,1,104,117.48ZM64,80a16,16,0,1,0-16-16A16,16,0,0,0,64,80Z">
                        </path>
                    </svg>
                    BizFlow
                </div>
                <div class="app-subtitle">„Ç¢„ÇØ„ÉÜ„Ç£„Éì„ÉÜ„Ç£Âõ≥‰ΩúÊàê„ÉÑ„Éº„É´ (v6.1)</div>
            </div>

            <div class="stencil-content">
                <div class="group-title">„Éé„Éº„Éâ</div>
                <div class="dnd-item" draggable="true" data-type="circle" title="ÈñãÂßã/ÁµÇ‰∫Ü">
                    <div class="shape-preview shape-circle"></div>
                    <span class="item-label">ÈñãÂßã / ÁµÇ‰∫Ü</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="rect" title="Âá¶ÁêÜ">
                    <div class="shape-preview shape-rect"></div>
                    <span class="item-label">Âá¶ÁêÜ</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="diamond" title="Âà§Êñ≠">
                    <div class="shape-preview shape-diamond"></div>
                    <span class="item-label">Âà§Êñ≠</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="db" title="„Éá„Éº„Çø„Çπ„Éà„Ç¢">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 40 40">
                            <path
                                d="M 0 6 A 20 6 0 1 1 40 6 A 20 6 0 1 1 0 6 z M 0 6 L 0 34 A 20 6 0 0 0 40 34 L 40 6 A 20 6 0 0 1 0 6"
                                fill="white" stroke="#1e293b" stroke-width="2"></path>
                        </svg>
                    </div>
                    <span class="item-label">„Éá„Éº„Çø„Çπ„Éà„Ç¢</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="text" title="„ÉÜ„Ç≠„Çπ„Éà">
                    <div class="shape-text">T</div>
                    <span class="item-label">„ÉÜ„Ç≠„Çπ„Éà</span>
                </div>

                <div class="group-title">„Ç≥„É≥„ÉÜ„Éä</div>
                <div class="dnd-item" draggable="true" data-type="swimlane" title="ÊãÖÂΩìÈ†òÂüü">
                    <div class="shape-preview shape-swimlane">
                        <div class="swimlane-line"></div>
                    </div>
                    <span class="item-label">ÊãÖÂΩìÈ†òÂüü</span>
                </div>
                <div style="height: 50px;"></div>
            </div>
            <div class="panel-header" style="text-align: center; font-size: 0.75rem; color: #94a3b8;">v6.1 Fixed</div>
        </div>

        <!-- CENTER PANEL -->
        <div class="flex flex-col relative overflow-hidden h-full">
            <div class="toolbar">
                <div class="flex items-center gap-2">
                    <button id="btn-undo" class="btn-icon" title="ÂÖÉ„Å´Êàª„Åô (Ctrl+Z)" disabled><svg viewBox="0 0 24 24">
                            <path
                                d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z">
                            </path>
                        </svg></button>
                    <button id="btn-redo" class="btn-icon" title="„ÇÑ„ÇäÁõ¥„Åó (Ctrl+Y)" disabled><svg viewBox="0 0 24 24">
                            <path
                                d="M18.4 10.6C16.55 9 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z">
                            </path>
                        </svg></button>
                    <div class="separator"></div>
                    <button id="btn-home" class="btn-icon" title="„Éõ„Éº„É†‰ΩçÁΩÆ„Å´Êàª„Çã"><svg viewBox="0 0 24 24">
                            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
                        </svg></button>
                    <button id="btn-fit" class="btn-icon" title="ÂÖ®‰Ωì„ÇíË°®Á§∫"><svg viewBox="0 0 24 24">
                            <path
                                d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6z">
                            </path>
                        </svg></button>
                    <div class="separator"></div>
                    <button id="btn-zoom-out" class="btn-icon" title="Á∏ÆÂ∞è"><svg viewBox="0 0 24 24">
                            <path d="M19 13H5v-2h14v2z"></path>
                        </svg></button>
                    <span id="zoom-level"
                        style="font-size: 0.875rem; font-family: monospace; width: 48px; text-align: center;">100%</span>
                    <button id="btn-zoom-in" class="btn-icon" title="Êã°Â§ß"><svg viewBox="0 0 24 24">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path>
                        </svg></button>
                </div>
                <div class="flex items-center gap-2">
                    <button id="btn-clear" class="btn-text btn-danger">„ÇØ„É™„Ç¢</button>
                    <div class="separator"></div>
                    <button id="btn-import" class="btn-text btn-secondary">JSON„Åã„ÇâË™≠Ëæº</button>

                    <div style="position: relative;">
                        <button id="btn-export-menu" class="btn-text btn-primary">‰øùÂ≠ò ‚ñº</button>
                        <div id="export-menu">
                            <button class="export-item" id="export-json">JSON„Éï„Ç°„Ç§„É´„Å®„Åó„Å¶‰øùÂ≠ò</button>
                            <button class="export-item" id="export-png">PNGÁîªÂÉè (ËÉåÊôØÈÄèÈÅé)</button>
                            <button class="export-item" id="export-jpeg">JPEGÁîªÂÉè (ËÉåÊôØ„ÅÇ„Çä)</button>
                            <button class="export-item" id="export-pdf">PDFÂç∞Âà∑ / ‰øùÂ≠ò</button>
                        </div>
                    </div>
                </div>
            </div>

            <div id="canvas-wrapper">
                <svg id="main-svg" width="100%" height="100%">
                    <defs>
                        <pattern id="grid-pattern" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e2e8f0" stroke-width="1" />
                        </pattern>
                        <!-- Markers -->
                        <marker id="arrow-end" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto"
                            markerUnits="strokeWidth">
                            <path d="M0,0 L0,6 L9,3 z" fill="#64748b" />
                        </marker>
                        <marker id="arrow-start" markerWidth="10" markerHeight="10" refX="0" refY="3" orient="auto"
                            markerUnits="strokeWidth">
                            <path d="M9,0 L9,6 L0,3 z" fill="#64748b" />
                        </marker>
                    </defs>
                    <rect id="bg-rect" width="100%" height="100%" fill="none"></rect>
                    <g id="viewport-group">
                        <g id="layer-swimlanes"></g>
                        <g id="layer-edges"></g>
                        <g id="layer-nodes"></g>
                        <g id="layer-ui"></g>
                    </g>
                </svg>
            </div>

            <div id="quick-add-menu">
                <div class="quick-add-item" data-type="rect" title="Âá¶ÁêÜ„ÇíËøΩÂä†">
                    <div class="shape-preview shape-rect" style="width:24px; height:16px;"></div>
                </div>
                <div class="quick-add-item" data-type="diamond" title="Âà§Êñ≠„ÇíËøΩÂä†">
                    <div class="shape-preview shape-diamond" style="width:20px; height:20px;"></div>
                </div>
                <div class="quick-add-item" data-type="db" title="DB„ÇíËøΩÂä†">
                    <div class="svg-icon-container" style="transform: scale(0.6);">
                        <svg viewBox="0 0 40 40">
                            <path
                                d="M 0 6 A 20 6 0 1 1 40 6 A 20 6 0 1 1 0 6 z M 0 6 L 0 34 A 20 6 0 0 0 40 34 L 40 6 A 20 6 0 0 1 0 6"
                                fill="white" stroke="#1e293b" stroke-width="2"></path>
                        </svg>
                    </div>
                </div>
                <div class="quick-add-item" data-type="circle" title="ÁµÇ‰∫Ü„ÇíËøΩÂä†">
                    <div class="shape-preview shape-circle" style="width:20px; height:20px;"></div>
                </div>
            </div>

            <div id="toast">‰øùÂ≠ò„Åó„Åæ„Åó„Åü</div>
        </div>

        <!-- RIGHT PANEL -->
        <div class="properties-panel border-l z-10 h-full overflow-hidden">
            <!-- Tabs -->
            <div class="tabs">
                <button class="tab-btn active" data-tab="prop">„Éó„É≠„Éë„ÉÜ„Ç£</button>
                <button class="tab-btn" data-tab="layer">„É¨„Ç§„É§„Éº</button>
            </div>

            <!-- Property Tab -->
            <div id="tab-prop" class="panel-content active">
                <div id="props-empty"
                    style="text-align: center; color: var(--text-muted); font-style: italic; margin-top: 2rem;">
                    Ë¶ÅÁ¥†„ÇíÈÅ∏Êäû„Åô„Çã„Å®<br>Ë©≥Á¥∞„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô
                </div>
                <div id="props-multi"
                    style="text-align: center; color: var(--text-muted); font-style: italic; margin-top: 2rem; display: none;">
                    Ë§áÊï∞È†ÖÁõÆ„ÇíÈÅ∏Êäû‰∏≠
                </div>
                <div id="props-content" style="display: none;">
                    <!-- Node Specific -->
                    <div id="group-node-type" class="prop-group">
                        <label class="prop-label">Á®ÆÈ°û (Type)</label>
                        <select id="prop-type" class="prop-input">
                            <option value="rect">Âá¶ÁêÜ (Action)</option>
                            <option value="circle">ÈñãÂßã/ÁµÇ‰∫Ü (Circle)</option>
                            <option value="diamond">Âà§Êñ≠ (Decision)</option>
                            <option value="db">„Éá„Éº„Çø„Çπ„Éà„Ç¢ (DB)</option>
                            <option value="text">„ÉÜ„Ç≠„Çπ„Éà (Text)</option>
                            <option value="swimlane">ÊãÖÂΩìÈ†òÂüü (Swimlane)</option>
                        </select>
                    </div>
                    <div id="group-edge-style" class="prop-group" style="display:none;">
                        <label class="prop-label">„Éû„Éº„Ç´„Éº (Áü¢Âç∞)</label>
                        <select id="prop-edge-marker" class="prop-input">
                            <option value="none">„Å™„Åó</option>
                            <option value="end">ÁµÇ‰∫ÜÁÇπ„ÅÆ„Åø (‚Üí)</option>
                            <option value="start">ÈñãÂßãÁÇπ„ÅÆ„Åø (‚Üê)</option>
                            <option value="both">‰∏°Á´Ø (‚Üî)</option>
                        </select>
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">ID</label>
                        <input type="text" id="prop-id" class="prop-input" readonly
                            style="background: #f1f5f9; font-family: monospace;">
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">„É©„Éô„É´„ÉÜ„Ç≠„Çπ„Éà</label>
                        <textarea id="prop-label" rows="3" class="prop-input"></textarea>
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">„Éï„Ç©„É≥„ÉàË®≠ÂÆö</label>
                        <div class="dimension-inputs">
                            <div>
                                <label style="font-size: 0.7rem; color: #94a3b8;">„Çµ„Ç§„Ç∫ (px)</label>
                                <input type="number" id="prop-font-size" class="prop-input" min="8" max="72">
                            </div>
                            <div>
                                <label style="font-size: 0.7rem; color: #94a3b8;">Ëâ≤</label>
                                <input type="color" id="prop-text-color"
                                    style="width: 100%; height: 34px; cursor: pointer;">
                            </div>
                        </div>
                        <div style="margin-top:0.5rem;">
                            <label style="font-size: 0.7rem; color: #94a3b8;">„ÉÜ„Ç≠„Çπ„ÉàËÉåÊôØ</label>
                            <div class="color-picker-row">
                                <input type="color" id="prop-text-bg-color"
                                    style="height: 32px; width: 64px; cursor: pointer;">
                                <button id="btn-text-bg-none" class="btn-text btn-secondary"
                                    style="font-size: 0.75rem;">„Å™„Åó</button>
                            </div>
                        </div>
                    </div>
                    <div class="prop-group" id="group-dimensions">
                        <label class="prop-label">„Çµ„Ç§„Ç∫</label>
                        <div class="dimension-inputs">
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">ÂπÖ (W)</label><input type="number"
                                    id="prop-w" class="prop-input"></div>
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">È´ò„Åï (H)</label><input type="number"
                                    id="prop-h" class="prop-input"></div>
                        </div>
                    </div>
                    <div class="prop-group" id="group-style">
                        <label class="prop-label">„Çπ„Çø„Ç§„É´</label>
                        <div style="margin-bottom: 0.5rem;">
                            <label style="font-size: 0.7rem; color: #94a3b8;">Êû†Á∑öÂ§™„Åï (px)</label>
                            <input type="number" id="prop-stroke-width" class="prop-input" min="0" max="10" value="2">
                        </div>
                        <div>
                            <label style="font-size: 0.7rem; color: #94a3b8;">Âõ≥ÂΩ¢ËÉåÊôØËâ≤</label>
                            <div class="color-picker-row">
                                <input type="color" id="prop-color" style="height: 32px; width: 64px; cursor: pointer;">
                                <button id="btn-reset-color" class="btn-text btn-secondary"
                                    style="font-size: 0.75rem;">„É™„Çª„ÉÉ„Éà</button>
                            </div>
                        </div>
                    </div>
                    <div style="height: 50px;"></div>
                </div>
            </div>

            <!-- Layer Tab -->
            <div id="tab-layer" class="panel-content">
                <div style="font-size:0.75rem; color:#64748b; margin-bottom:0.5rem;">‰∏ä„Å´„ÅÇ„ÇãÈ†ÖÁõÆ„ÅåÊâãÂâç„Å´Ë°®Á§∫„Åï„Çå„Åæ„Åô„ÄÇ<br>„Éâ„É©„ÉÉ„Ç∞„ÅßÈ†ÜÂ∫èÂ§âÊõ¥ÂèØËÉΩ„Åß„Åô„ÄÇ
                </div>
                <ul id="layer-list" class="layer-list"></ul>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".json" style="display: none;">

    <script>
        /** BizFlow Designer - Offline Logic v6.1 */
        const GRID_SIZE = 10;
        const STORAGE_KEY = 'bizflow_offline_data_v6';
        const MIN_SIZE = 40;

        // Global State
        const state = {
            nodes: [], edges: [], zoom: 1, pan: { x: 0, y: 0 },
            selection: [], clipboard: null, history: [], historyIndex: -1,
            isDragging: false, dragTarget: null, dragStart: { x: 0, y: 0, rawX: 0, rawY: 0 },
            dragItemOffset: {}, tempLine: null, rubberbandRect: null,
            quickAdd: { visible: false, sourceNodeId: null, portDir: null, x: 0, y: 0 },
            activeTab: 'prop', layerDragIdx: null
        };

        // DOM Elements
        const svgEl = document.getElementById('main-svg');
        const viewportEl = document.getElementById('viewport-group');
        const layerSwimlanes = document.getElementById('layer-swimlanes');
        const layerNodes = document.getElementById('layer-nodes');
        const layerEdges = document.getElementById('layer-edges');
        const layerUI = document.getElementById('layer-ui');
        const wrapperEl = document.getElementById('canvas-wrapper');
        const quickAddMenu = document.getElementById('quick-add-menu');
        const exportMenu = document.getElementById('export-menu');
        const layerListEl = document.getElementById('layer-list');

        // --- UTILS ---
        const uuid = () => 'id-' + Math.random().toString(36).substr(2, 9);
        const snap = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;

        function getMousePos(evt) {
            let cx, cy;
            // Support touch events or Mouse events
            if (evt.touches && evt.touches.length > 0) {
                cx = evt.touches[0].clientX; cy = evt.touches[0].clientY;
            } else if (evt.clientX !== undefined) {
                cx = evt.clientX; cy = evt.clientY;
            } else {
                return { x: 0, y: 0 };
            }

            const CTM = svgEl.getScreenCTM();
            if (!CTM) return { x: 0, y: 0 };
            return {
                x: (cx - CTM.e - state.pan.x) / state.zoom,
                y: (cy - CTM.f - state.pan.y) / state.zoom
            };
        }

        function createMultilineText(text, x, y, isSwimlane, size, color, isTextNode) {
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            const lines = text.split('\n');
            const fontSize = size || 14;
            const lineHeight = fontSize * 1.2;
            t.style.fontSize = fontSize + 'px';
            if (color) t.style.fill = color;

            let startY = y;
            if (!isSwimlane && !isTextNode) startY = y - ((lines.length - 1) * lineHeight) / 2 + (fontSize * 0.35);
            if (isTextNode) startY = y - ((lines.length - 1) * lineHeight) / 2 + (fontSize * 0.35);

            lines.forEach((line, i) => {
                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                tspan.textContent = line;
                tspan.setAttribute('x', x);
                tspan.setAttribute('dy', i === 0 ? 0 : lineHeight);
                if (i === 0) tspan.setAttribute('y', startY);
                t.appendChild(tspan);
            });
            return t;
        }

        function parsePathPoints(d) {
            const parts = d.split(' ');
            const points = [];
            for (let i = 0; i < parts.length; i += 3) {
                if (parts[i] === 'M' || parts[i] === 'L') points.push({ x: parseFloat(parts[i + 1]), y: parseFloat(parts[i + 2]) });
            }
            return points;
        }

        function getEdgeLabelPosition(d) {
            const points = parsePathPoints(d);
            if (points.length < 2) return { x: 0, y: 0, orientation: 'horizontal' };
            let p1, p2;
            if (points.length === 2) { p1 = points[0]; p2 = points[1]; }
            else if (points.length >= 4) {
                const mid = Math.floor(points.length / 2);
                if (mid > 0) { p1 = points[mid - 1]; p2 = points[mid]; } else { p1 = points[0]; p2 = points[1]; }
            } else { p1 = points[0]; p2 = points[points.length - 1]; }

            const mx = (p1.x + p2.x) / 2;
            const my = (p1.y + p2.y) / 2;
            const orientation = Math.abs(p1.x - p2.x) > Math.abs(p1.y - p2.y) ? 'horizontal' : 'vertical';
            return { x: mx, y: my, orientation };
        }

        function getPortPos(node, dir) {
            if (!dir) return { x: node.x + node.w / 2, y: node.y + node.h / 2 };
            if (dir === 'top') return { x: node.x + node.w / 2, y: node.y };
            if (dir === 'right') return { x: node.x + node.w, y: node.y + node.h / 2 };
            if (dir === 'bottom') return { x: node.x + node.w / 2, y: node.y + node.h };
            if (dir === 'left') return { x: node.x, y: node.y + node.h / 2 };
            return { x: node.x + node.w / 2, y: node.y + node.h / 2 };
        }

        function getManhattanPath(source, sourceDir, target, targetDir) {
            const s = getPortPos(source, sourceDir);
            const t = getPortPos(target, targetDir);
            const stub = 20;
            let sx = s.x, sy = s.y;
            if (sourceDir === 'top') sy -= stub; else if (sourceDir === 'bottom') sy += stub; else if (sourceDir === 'left') sx -= stub; else if (sourceDir === 'right') sx += stub;
            let tx = t.x, ty = t.y;
            if (targetDir === 'top') ty -= stub; else if (targetDir === 'bottom') ty += stub; else if (targetDir === 'left') tx -= stub; else if (targetDir === 'right') tx += stub;

            let d = `M ${s.x} ${s.y} L ${sx} ${sy}`;
            const mx = (sx + tx) / 2; const my = (sy + ty) / 2;

            if ((sourceDir === 'left' || sourceDir === 'right') && (targetDir === 'left' || targetDir === 'right')) {
                d += ` L ${mx} ${sy} L ${mx} ${ty} L ${tx} ${ty}`;
            } else if ((sourceDir === 'top' || sourceDir === 'bottom') && (targetDir === 'top' || targetDir === 'bottom')) {
                d += ` L ${sx} ${my} L ${tx} ${my} L ${tx} ${ty}`;
            } else {
                let simpleL = false;
                if (sourceDir === 'right' && tx > sx) simpleL = true;
                if (sourceDir === 'left' && tx < sx) simpleL = true;
                if (sourceDir === 'bottom' && ty > sy) simpleL = true;
                if (sourceDir === 'top' && ty < sy) simpleL = true;
                if (simpleL) {
                    if (sourceDir === 'left' || sourceDir === 'right') d += ` L ${tx} ${sy} L ${tx} ${ty}`; else d += ` L ${sx} ${ty} L ${tx} ${ty}`;
                } else {
                    if (sourceDir === 'left' || sourceDir === 'right') d += ` L ${mx} ${sy} L ${mx} ${ty} L ${tx} ${ty}`; else d += ` L ${sx} ${my} L ${tx} ${my} L ${tx} ${ty}`;
                }
            }
            d += ` L ${t.x} ${t.y}`;
            return d;
        }

        // --- UI Update ---
        function updateLayerPanel() {
            if (!layerListEl) return;
            layerListEl.innerHTML = '';
            const indexedNodes = state.nodes.map((n, i) => ({ ...n, _idx: i }));
            const reversed = indexedNodes.reverse();
            reversed.forEach((node) => {
                const li = document.createElement('li');
                li.className = 'layer-item';
                li.draggable = true;
                li.dataset.id = node.id;
                let iconChar = '‚¨ú';
                if (node.type === 'circle') iconChar = '‚ö™'; if (node.type === 'diamond') iconChar = '‚óá'; if (node.type === 'db') iconChar = 'üõ¢Ô∏è'; if (node.type === 'swimlane') iconChar = '‚ò∞'; if (node.type === 'text') iconChar = 'T';
                const label = node.label ? node.label.replace(/\n/g, ' ') : `(No Label)`;
                li.innerHTML = `<div class="layer-item-content"><span class="layer-icon">${iconChar}</span><span class="layer-name">${label}</span></div><span class="layer-handle">‚ò∞</span>`;
                li.addEventListener('dragstart', (e) => {
                    state.layerDragIdx = node._idx;
                    li.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move';
                });
                li.addEventListener('dragend', () => { li.classList.remove('dragging'); state.layerDragIdx = null; });
                li.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; });
                li.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIdx = state.layerDragIdx; const toIdx = node._idx;
                    if (fromIdx !== null && fromIdx !== toIdx) {
                        const movedNode = state.nodes[fromIdx];
                        state.nodes.splice(fromIdx, 1);
                        state.nodes.splice(toIdx, 0, movedNode);
                        saveState(); render();
                    }
                });
                li.addEventListener('click', (e) => { handleSelection(e, node.id); });
                if (state.selection.includes(node.id)) { li.style.borderColor = 'var(--primary-color)'; li.style.backgroundColor = '#f0f9ff'; }
                layerListEl.appendChild(li);
            });
        }

        function updatePropsPanel() {
            const empty = document.getElementById('props-empty');
            const multi = document.getElementById('props-multi');
            const content = document.getElementById('props-content');
            const dimGroup = document.getElementById('group-dimensions');
            const styleGroup = document.getElementById('group-style');
            const edgeGroup = document.getElementById('group-edge-style');
            const nodeTypeGroup = document.getElementById('group-node-type');

            if (state.selection.length === 0) {
                empty.style.display = 'block'; multi.style.display = 'none'; content.style.display = 'none';
            } else if (state.selection.length > 1) {
                empty.style.display = 'none'; multi.style.display = 'block'; content.style.display = 'none';
            } else {
                empty.style.display = 'none'; multi.style.display = 'none'; content.style.display = 'block';
                const id = state.selection[0];
                const node = state.nodes.find(n => n.id === id);
                const edge = state.edges.find(e => e.id === id);
                const el = node || edge;
                if (el) {
                    document.getElementById('prop-id').value = el.id;
                    document.getElementById('prop-label').value = el.label || '';
                    document.getElementById('prop-font-size').value = el.fontSize || 14;
                    document.getElementById('prop-text-color').value = el.textColor || '#000000';
                    document.getElementById('prop-text-bg-color').value = (el.textBgColor && el.textBgColor !== 'transparent') ? el.textBgColor : '#ffffff';
                    if (node) {
                        nodeTypeGroup.style.display = 'block'; edgeGroup.style.display = 'none';
                        dimGroup.style.display = 'block'; styleGroup.style.display = 'block';
                        document.getElementById('prop-type').value = node.type;
                        document.getElementById('prop-w').value = node.w;
                        document.getElementById('prop-h').value = node.h;
                        document.getElementById('prop-color').value = node.bgColor || '#ffffff';
                        document.getElementById('prop-stroke-width').value = node.strokeWidth !== undefined ? node.strokeWidth : 2;
                    } else if (edge) {
                        nodeTypeGroup.style.display = 'none'; dimGroup.style.display = 'none';
                        styleGroup.style.display = 'none'; edgeGroup.style.display = 'block';
                        document.getElementById('prop-edge-marker').value = edge.marker || 'end';
                    }
                }
            }
        }

        // --- RENDER ---
        function render() {
            layerSwimlanes.innerHTML = ''; layerNodes.innerHTML = ''; layerEdges.innerHTML = '';
            const tempChildren = Array.from(layerUI.children);
            tempChildren.forEach(c => { if (c !== state.tempLine && c !== state.rubberbandRect) layerUI.removeChild(c); });
            viewportEl.setAttribute('transform', `translate(${state.pan.x}, ${state.pan.y}) scale(${state.zoom})`);

            state.edges.forEach(edge => {
                const sourceNode = state.nodes.find(n => n.id === edge.source);
                const targetNode = state.nodes.find(n => n.id === edge.target);
                if (!sourceNode || !targetNode) return;
                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.dataset.id = edge.id; group.style.cursor = 'pointer';
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const isSelected = state.selection.includes(edge.id);
                path.setAttribute('class', `connector-path ${isSelected ? 'selected' : ''}`);
                const d = getManhattanPath(sourceNode, edge.sourcePort, targetNode, edge.targetPort);
                path.setAttribute('d', d);
                const markerType = edge.marker || 'end';
                if (markerType === 'end' || markerType === 'both') path.setAttribute('marker-end', 'url(#arrow-end)');
                if (markerType === 'start' || markerType === 'both') path.setAttribute('marker-start', 'url(#arrow-start)');
                group.appendChild(path);
                if (edge.label) {
                    const center = getEdgeLabelPosition(d);
                    if (edge.textBgColor && edge.textBgColor !== 'transparent') {
                        const lines = edge.label.split('\n'); const fs = edge.fontSize || 14;
                        const maxLineLen = Math.max(...lines.map(l => l.length));
                        const w = Math.max(20, maxLineLen * (fs * 0.6) + 10); const h = lines.length * (fs * 1.2) + 4;
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('class', 'text-bg-rect'); bg.setAttribute('fill', edge.textBgColor);
                        bg.setAttribute('x', center.x - w / 2); bg.setAttribute('y', center.y - h / 2);
                        bg.setAttribute('width', w); bg.setAttribute('height', h);
                        group.appendChild(bg);
                    } else {
                        if (center.orientation === 'horizontal') center.y -= 10; else center.x += 5;
                    }
                    const text = createMultilineText(edge.label, center.x, center.y, false, edge.fontSize, edge.textColor, false);
                    text.setAttribute('class', 'edge-label-text'); group.appendChild(text);
                }
                group.addEventListener('mousedown', (e) => { handleSelection(e, edge.id); e.stopPropagation(); });
                layerEdges.appendChild(group);
            });

            state.nodes.forEach(node => {
                const isSwimlane = node.type === 'swimlane'; const isText = node.type === 'text';
                const targetLayer = isSwimlane ? layerSwimlanes : layerNodes;
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const isSelected = state.selection.includes(node.id);
                g.setAttribute('class', `node-group ${isSelected ? 'selected' : ''} ${isText ? 'text-node' : ''}`);
                g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                g.dataset.id = node.id;

                let shape = null;
                if (node.type === 'circle') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    shape.setAttribute('cx', node.w / 2); shape.setAttribute('cy', node.h / 2);
                    shape.setAttribute('r', Math.min(node.w, node.h) / 2);
                } else if (node.type === 'diamond') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const w = node.w, h = node.h;
                    shape.setAttribute('points', `${w / 2},0 ${w},${h / 2} ${w / 2},${h} 0,${h / 2}`);
                } else if (node.type === 'db') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const w = node.w, h = node.h; const ry = h * 0.15;
                    shape.setAttribute('d', `M 0 ${ry} A ${w / 2} ${ry} 0 1 1 ${w} ${ry} A ${w / 2} ${ry} 0 1 1 0 ${ry} z M 0 ${ry} L 0 ${h - ry} A ${w / 2} ${ry} 0 0 0 ${w} ${h - ry} L ${w} ${ry} A ${w / 2} ${ry} 0 0 1 0 ${ry}`);
                    shape.setAttribute('fill-rule', 'evenodd');
                } else if (isText) {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shape.setAttribute('width', node.w); shape.setAttribute('height', node.h);
                    shape.setAttribute('fill', 'transparent'); shape.setAttribute('stroke', 'none');
                } else {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shape.setAttribute('width', node.w); shape.setAttribute('height', node.h);
                    shape.setAttribute('rx', node.type === 'rect' ? 6 : 0);
                }
                if (shape) {
                    if (!isText) {
                        shape.setAttribute('class', 'node-body');
                        const sw = node.strokeWidth !== undefined ? node.strokeWidth : 2;
                        shape.setAttribute('stroke-width', sw);
                        if (sw === 0) shape.setAttribute('stroke', 'none');
                        if (isSwimlane) {
                            shape.setAttribute('stroke-dasharray', '5 5');
                            shape.setAttribute('fill', node.bgColor || '#f8fafc');
                            shape.setAttribute('fill-opacity', (!node.bgColor || node.bgColor === '#ffffff') ? '0.5' : '1');
                        } else {
                            shape.setAttribute('fill', node.bgColor || '#ffffff');
                        }
                    }
                    g.appendChild(shape);
                }

                let textX = node.w / 2; let textY = isSwimlane ? 20 : node.h / 2; let anchor = 'middle';
                if (isText) { textX = 0; textY = node.h / 2; anchor = 'start'; }
                if (node.label) {
                    if (node.textBgColor && node.textBgColor !== 'transparent') {
                        const lines = node.label.split('\n'); const fs = node.fontSize || 14;
                        const maxLineLen = Math.max(...lines.map(l => l.length));
                        const tw = Math.max(20, maxLineLen * (fs * 0.7) + 10);
                        const th = lines.length * (fs * 1.3) + 4;
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('class', 'text-bg-rect'); bg.setAttribute('fill', node.textBgColor);
                        let bgX = textX - tw / 2; let bgY = textY - th / 2;
                        if (anchor === 'start') bgX = textX - 2;
                        if (isSwimlane) bgY = textY - fs; else if (isText) bgY = textY - (lines.length * (fs * 1.2)) / 2; else bgY = textY - (lines.length * (fs * 1.2)) / 2;
                        bg.setAttribute('x', bgX); bg.setAttribute('y', bgY); bg.setAttribute('width', tw); bg.setAttribute('height', th);
                        g.appendChild(bg);
                    }
                    const text = createMultilineText(node.label, textX, textY, isSwimlane, node.fontSize, node.textColor, isText);
                    text.setAttribute('class', 'node-label'); text.setAttribute('text-anchor', anchor);
                    if (isSwimlane) text.style.fontWeight = 'bold';
                    g.appendChild(text);
                }

                if (!isSwimlane && !isText) {
                    const portsCoords = [{ x: node.w / 2, y: 0, dir: 'top' }, { x: node.w, y: node.h / 2, dir: 'right' }, { x: node.w / 2, y: node.h, dir: 'bottom' }, { x: 0, y: node.h / 2, dir: 'left' }];
                    portsCoords.forEach(p => {
                        const port = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        port.setAttribute('class', 'port'); port.setAttribute('cx', p.x); port.setAttribute('cy', p.y); port.setAttribute('r', 4);
                        port.addEventListener('mousedown', (e) => { e.stopPropagation(); startConnectionDrag(e, node, p); });
                        port.addEventListener('contextmenu', (e) => { e.preventDefault(); e.stopPropagation(); showQuickAddMenu(e, node, p); });
                        port.dataset.nodeId = node.id; port.dataset.dir = p.dir;
                        g.appendChild(port);
                    });
                }
                if (isSelected && state.selection.length === 1 && !isText) {
                    const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    handle.setAttribute('class', 'resize-handle'); handle.setAttribute('x', node.w - 5); handle.setAttribute('y', node.h - 5);
                    handle.addEventListener('mousedown', (e) => { e.stopPropagation(); startResizeDrag(e, node); });
                    g.appendChild(handle);
                }
                g.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('port') || e.target.classList.contains('resize-handle')) return;
                    handleSelection(e, node.id); startNodeDrag(e); e.stopPropagation();
                });
                g.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    const newLabel = prompt('„É©„Éô„É´Á∑®ÈõÜ:', node.label);
                    if (newLabel !== null) { node.label = newLabel.replace(/\\n/g, '\n'); saveState(); render(); updatePropsPanel(); }
                });
                targetLayer.appendChild(g);
            });

            if (state.selection.length === 1) {
                const node = state.nodes.find(n => n.id === state.selection[0]);
                if (node && node.type !== 'swimlane' && node.type !== 'text') {
                    const padding = 20;
                    const handles = [{ dir: 'top', x: node.x + node.w / 2, y: node.y - padding }, { dir: 'bottom', x: node.x + node.w / 2, y: node.y + node.h + padding }, { dir: 'left', x: node.x - padding, y: node.y + node.h / 2 }, { dir: 'right', x: node.x + node.w + padding, y: node.y + node.h / 2 }];
                    handles.forEach(h => {
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('class', 'quick-add-group'); g.style.cursor = 'pointer';
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('class', 'quick-add-handle'); circle.setAttribute('cx', h.x); circle.setAttribute('cy', h.y); circle.setAttribute('r', 8);
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('class', 'quick-add-symbol'); path.setAttribute('d', `M ${h.x - 4} ${h.y} L ${h.x + 4} ${h.y} M ${h.x} ${h.y - 4} L ${h.x} ${h.y + 4}`);
                        g.appendChild(circle); g.appendChild(path);
                        g.addEventListener('mousedown', (e) => { e.stopPropagation(); showQuickAddMenu(e, node, { dir: h.dir }, true); });
                        layerUI.appendChild(g);
                    });
                }
            }
            if (state.activeTab === 'layer') updateLayerPanel();
        }

        function handleSelection(e, id) {
            if (e.shiftKey || e.ctrlKey) {
                if (state.selection.includes(id)) state.selection = state.selection.filter(sid => sid !== id);
                else state.selection.push(id);
            } else {
                if (state.selection.length > 1 && state.selection.includes(id)) { } else { state.selection = [id]; }
            }
            render(); updatePropsPanel();
        }

        function showQuickAddMenu(e, node, p, fromHandle = false) {
            state.quickAdd = { visible: true, sourceNodeId: node.id, portDir: p.dir, x: e.clientX, y: e.clientY };
            quickAddMenu.style.left = e.clientX + 'px'; quickAddMenu.style.top = e.clientY + 'px'; quickAddMenu.style.display = 'grid';
        }
        function hideQuickAddMenu() { quickAddMenu.style.display = 'none'; state.quickAdd.visible = false; }

        function startNodeDrag(e) {
            state.isDragging = true; state.dragTarget = 'node';
            const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            state.dragStart = { rawX, rawY };
            state.dragItemOffset = {};
            state.selection.forEach(id => {
                const n = state.nodes.find(node => node.id === id);
                if (n) state.dragItemOffset[id] = { x: n.x, y: n.y };
            });
        }
        function startResizeDrag(e, node) {
            state.isDragging = true; state.dragTarget = 'resize';
            const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            state.dragStart = { rawX, rawY };
            state.dragItemOffset = { w: node.w, h: node.h, id: node.id };
        }
        function startConnectionDrag(e, sourceNode, portConfig) {
            state.isDragging = true; state.dragTarget = 'port';
            state.dragStart = { nodeId: sourceNode.id, portDir: portConfig.dir, x: sourceNode.x + portConfig.x, y: sourceNode.y + portConfig.y };
            state.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            state.tempLine.setAttribute('stroke', '#3b82f6'); state.tempLine.setAttribute('stroke-width', '2'); state.tempLine.setAttribute('stroke-dasharray', '4 4');
            const sx = state.dragStart.x, sy = state.dragStart.y;
            state.tempLine.setAttribute('x1', sx); state.tempLine.setAttribute('y1', sy); state.tempLine.setAttribute('x2', sx); state.tempLine.setAttribute('y2', sy);
            layerUI.appendChild(state.tempLine);
        }
        function startRubberband(e) {
            state.isDragging = true; state.dragTarget = 'rubberband';
            const pos = getMousePos(e);
            state.dragStart = { x: pos.x, y: pos.y };
            state.rubberbandRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            state.rubberbandRect.setAttribute('class', 'rubberband');
            state.rubberbandRect.setAttribute('x', pos.x); state.rubberbandRect.setAttribute('y', pos.y);
            layerUI.appendChild(state.rubberbandRect);
            if (!e.shiftKey && !e.ctrlKey) state.selection = []; render();
        }
        function startPan(e) {
            state.isDragging = true; state.dragTarget = 'pan';
            const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            state.dragStart = { x: rawX, y: rawY };
            state.dragItemOffset = { ...state.pan };
            wrapperEl.style.cursor = 'grabbing';
        }

        function saveState() {
            if (state.historyIndex < state.history.length - 1) state.history = state.history.slice(0, state.historyIndex + 1);
            const s = JSON.stringify({ nodes: state.nodes, edges: state.edges });
            state.history.push(s); state.historyIndex++;
            updateBtns();
            try { localStorage.setItem(STORAGE_KEY, s); } catch (e) { }
            showToast('‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
        }
        function undo() { if (state.historyIndex > 0) { state.historyIndex--; restore(state.history[state.historyIndex]); } }
        function redo() { if (state.historyIndex < state.history.length - 1) { state.historyIndex++; restore(state.history[state.historyIndex]); } }
        function restore(s) { const d = JSON.parse(s); state.nodes = d.nodes; state.edges = d.edges; state.selection = []; render(); updateBtns(); }
        function updateBtns() {
            document.getElementById('btn-undo').disabled = state.historyIndex <= 0;
            document.getElementById('btn-redo').disabled = state.historyIndex >= state.history.length - 1;
        }
        function showToast(msg) {
            const t = document.getElementById('toast'); t.textContent = msg; t.style.opacity = '1';
            setTimeout(() => t.style.opacity = '0', 2000);
        }
        function setZoom(v) { state.zoom = Math.max(0.2, Math.min(3, v)); document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%'; render(); }
        function updateSelectedProps(key, value, isInt = false) {
            let changed = false;
            state.selection.forEach(id => {
                const n = state.nodes.find(node => node.id === id);
                const e = state.edges.find(edge => edge.id === id);
                const target = n || e;
                if (target) { target[key] = isInt ? parseInt(value) : value; changed = true; }
            });
            if (changed) render();
            return changed;
        }

        // --- EVENT LISTENERS ---

        // Toolbar
        document.getElementById('btn-undo').addEventListener('click', undo);
        document.getElementById('btn-redo').addEventListener('click', redo);
        document.getElementById('btn-home').addEventListener('click', () => { state.pan = { x: 0, y: 0 }; state.zoom = 1; setZoom(1); });
        document.getElementById('btn-clear').addEventListener('click', () => { if (confirm('ÂÖ®„Å¶„ÇØ„É™„Ç¢„Åó„Åæ„Åô„ÅãÔºü')) { state.nodes = []; state.edges = []; saveState(); render(); } });
        document.getElementById('btn-zoom-in').addEventListener('click', () => setZoom(state.zoom + 0.1));
        document.getElementById('btn-zoom-out').addEventListener('click', () => setZoom(state.zoom - 0.1));
        document.getElementById('btn-fit').addEventListener('click', () => { state.zoom = 1; state.pan = { x: 0, y: 0 }; setZoom(1); });

        // Properties
        document.getElementById('prop-label').addEventListener('input', (e) => updateSelectedProps('label', e.target.value));
        document.getElementById('prop-label').addEventListener('change', saveState);
        document.getElementById('prop-type').addEventListener('change', (e) => { updateSelectedProps('type', e.target.value); saveState(); });
        document.getElementById('prop-font-size').addEventListener('input', (e) => { updateSelectedProps('fontSize', e.target.value, true); saveState(); });
        document.getElementById('prop-text-color').addEventListener('input', (e) => { updateSelectedProps('textColor', e.target.value); saveState(); });
        document.getElementById('prop-text-bg-color').addEventListener('input', (e) => { updateSelectedProps('textBgColor', e.target.value); saveState(); });
        document.getElementById('btn-text-bg-none').addEventListener('click', () => { updateSelectedProps('textBgColor', 'transparent'); saveState(); });
        document.getElementById('prop-color').addEventListener('input', (e) => { updateSelectedProps('bgColor', e.target.value); saveState(); });
        document.getElementById('prop-stroke-width').addEventListener('input', (e) => { updateSelectedProps('strokeWidth', e.target.value, true); saveState(); });
        document.getElementById('btn-reset-color').addEventListener('click', () => { updateSelectedProps('bgColor', '#ffffff'); document.getElementById('prop-color').value = '#ffffff'; saveState(); });
        document.getElementById('prop-edge-marker').addEventListener('change', (e) => { updateSelectedProps('marker', e.target.value); saveState(); });
        document.getElementById('prop-w').addEventListener('input', (e) => {
            if (state.selection.length === 1) { const n = state.nodes.find(x => x.id === state.selection[0]); if (n) { n.w = Math.max(MIN_SIZE, snap(parseInt(e.target.value))); render(); saveState(); } }
        });
        document.getElementById('prop-h').addEventListener('input', (e) => {
            if (state.selection.length === 1) { const n = state.nodes.find(x => x.id === state.selection[0]); if (n) { n.h = Math.max(MIN_SIZE, snap(parseInt(e.target.value))); render(); saveState(); } }
        });

        // Global
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.panel-content').forEach(p => p.classList.remove('active'));
                btn.classList.add('active');
                const tabId = `tab-${btn.dataset.tab}`;
                document.getElementById(tabId).classList.add('active');
                state.activeTab = btn.dataset.tab;
                if (state.activeTab === 'layer') updateLayerPanel();
            });
        });

        document.querySelectorAll('.quick-add-item').forEach(item => {
            item.addEventListener('click', (e) => {
                if (!state.quickAdd.visible) return;
                const type = item.dataset.type;
                const sourceNode = state.nodes.find(n => n.id === state.quickAdd.sourceNodeId);
                if (!sourceNode) return;
                let w = 120, h = 60, lbl = 'Âá¶ÁêÜ';
                if (type === 'circle') { w = 60; h = 60; lbl = 'ÁµÇ‰∫Ü'; }
                if (type === 'diamond') { w = 80; h = 80; lbl = '?'; }
                if (type === 'db') { w = 60; h = 60; lbl = 'DB'; }
                const offset = 80;
                let nx = sourceNode.x, ny = sourceNode.y;
                const dir = state.quickAdd.portDir;
                if (dir === 'top') { nx += (sourceNode.w - w) / 2; ny -= (h + offset); }
                if (dir === 'bottom') { nx += (sourceNode.w - w) / 2; ny += (sourceNode.h + offset); }
                if (dir === 'left') { nx -= (w + offset); ny += (sourceNode.h - h) / 2; }
                if (dir === 'right') { nx += (sourceNode.w + offset); ny += (sourceNode.h - h) / 2; }
                const newNode = { id: uuid(), type: type, x: snap(nx), y: snap(ny), w: w, h: h, label: lbl, bgColor: '#ffffff', strokeWidth: 2 };
                let targetDir = 'top';
                if (dir === 'top') targetDir = 'bottom'; if (dir === 'bottom') targetDir = 'top'; if (dir === 'left') targetDir = 'right'; if (dir === 'right') targetDir = 'left';
                state.nodes.push(newNode);
                state.edges.push({ id: uuid(), source: sourceNode.id, sourcePort: dir, target: newNode.id, targetPort: targetDir, label: '' });
                state.selection = [newNode.id];
                saveState(); render(); hideQuickAddMenu();
            });
        });

        // MOUSE EVENTS
        window.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;
            const CTM = svgEl.getScreenCTM();
            const mouseX = (e.clientX - CTM.e - state.pan.x) / state.zoom;
            const mouseY = (e.clientY - CTM.f - state.pan.y) / state.zoom;

            if (state.dragTarget === 'node') {
                const deltaX = (e.clientX - state.dragStart.rawX) / state.zoom;
                const deltaY = (e.clientY - state.dragStart.rawY) / state.zoom;
                state.selection.forEach(id => {
                    const node = state.nodes.find(n => n.id === id);
                    if (node && state.dragItemOffset[id]) {
                        node.x = snap(state.dragItemOffset[id].x + deltaX);
                        node.y = snap(state.dragItemOffset[id].y + deltaY);
                    }
                });
                requestAnimationFrame(render);
            } else if (state.dragTarget === 'resize') {
                const node = state.nodes.find(n => n.id === state.dragItemOffset.id);
                if (node) {
                    const deltaX = (e.clientX - state.dragStart.rawX) / state.zoom;
                    const deltaY = (e.clientY - state.dragStart.rawY) / state.zoom;
                    node.w = Math.max(MIN_SIZE, snap(state.dragItemOffset.w + deltaX));
                    node.h = Math.max(MIN_SIZE, snap(state.dragItemOffset.h + deltaY));
                    requestAnimationFrame(render);
                }
            } else if (state.dragTarget === 'port') {
                state.tempLine.setAttribute('x2', mouseX); state.tempLine.setAttribute('y2', mouseY);
            } else if (state.dragTarget === 'pan') {
                const dx = e.clientX - state.dragStart.x;
                const dy = e.clientY - state.dragStart.y;
                state.pan.x = state.dragItemOffset.x + dx; state.pan.y = state.dragItemOffset.y + dy;
                requestAnimationFrame(render);
            } else if (state.dragTarget === 'rubberband') {
                const x = Math.min(state.dragStart.x, mouseX);
                const y = Math.min(state.dragStart.y, mouseY);
                const w = Math.abs(mouseX - state.dragStart.x);
                const h = Math.abs(mouseY - state.dragStart.y);
                state.rubberbandRect.setAttribute('x', x); state.rubberbandRect.setAttribute('y', y);
                state.rubberbandRect.setAttribute('width', w); state.rubberbandRect.setAttribute('height', h);
            }
        });

        svgEl.addEventListener('mousedown', (e) => {
            if (state.quickAdd.visible) hideQuickAddMenu();
            if (exportMenu.style.display === 'flex') exportMenu.style.display = 'none';
            if (e.button === 0) {
                if (e.code === 'Space' || e.button === 1) startPan(e);
                else if (e.target.id === 'main-svg' || e.target.id === 'bg-rect') startRubberband(e);
            }
        });

        // SCROLL / ZOOM
        wrapperEl.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.ctrlKey) {
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                setZoom(state.zoom + delta);
            } else {
                let dx = -e.deltaX; let dy = -e.deltaY;
                if (dx === 0 && e.shiftKey) { dx = -e.deltaY; dy = 0; }
                state.pan.x += dx; state.pan.y += dy; render();
            }
        }, { passive: false });

        // TOUCH EVENTS (Zoom/Pan)
        let touchStartDist = 0;
        let touchStartZoom = 1;
        let touchStartPan = { x: 0, y: 0 };

        wrapperEl.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                // Let D&D logic handle 1 finger tap on items if mapped, but if on bg...
                // Currently using Mouse events mapped. But if dragging bg (pan):
                if (e.target.id === 'main-svg' || e.target.id === 'bg-rect') {
                    startPan(e.touches[0]);
                }
            } else if (e.touches.length === 2) {
                state.isDragging = true;
                state.dragTarget = 'pinch';
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartZoom = state.zoom;
            }
        }, { passive: false });

        wrapperEl.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && state.dragTarget === 'pan') {
                e.preventDefault(); // Stop scroll
                const touch = e.touches[0];
                const dx = touch.clientX - state.dragStart.x;
                const dy = touch.clientY - state.dragStart.y;
                state.pan.x = state.dragItemOffset.x + dx;
                state.pan.y = state.dragItemOffset.y + dy;
                render();
            } else if (e.touches.length === 2 && state.dragTarget === 'pinch') {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (touchStartDist > 0) {
                    const scale = dist / touchStartDist;
                    setZoom(touchStartZoom * scale);
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            if (state.dragTarget === 'pinch' || state.dragTarget === 'pan') {
                state.isDragging = false;
                state.dragTarget = null;
                wrapperEl.style.cursor = 'default';
            }
        });

        // KEYBOARD
        window.addEventListener('keydown', (e) => {
            const activeTag = document.activeElement ? document.activeElement.tagName.toUpperCase() : '';
            const isInput = (activeTag === 'INPUT' || activeTag === 'TEXTAREA');
            if (e.code === 'Space' && !isInput) wrapperEl.style.cursor = 'grab';
            if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !isInput) {
                e.preventDefault();
                state.selection = [...state.nodes.map(n => n.id), ...state.edges.map(e => e.id)];
                render(); updatePropsPanel();
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && !isInput && state.selection.length > 0) {
                if (confirm('ÈÅ∏ÊäûÈ†ÖÁõÆ„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) {
                    state.nodes = state.nodes.filter(n => !state.selection.includes(n.id));
                    state.edges = state.edges.filter(edge => !state.selection.includes(edge.id) && !state.selection.includes(edge.source) && !state.selection.includes(edge.target));
                    state.selection = []; saveState(); render(); updatePropsPanel();
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !isInput) {
                if (state.selection.length > 0) {
                    const n = state.nodes.filter(n => state.selection.includes(n.id));
                    const e = state.edges.filter(e => state.selection.includes(e.source) && state.selection.includes(e.target));
                    state.clipboard = JSON.parse(JSON.stringify({ nodes: n, edges: e }));
                    showToast('„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü');
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !isInput) {
                if (state.clipboard) {
                    const idMap = {}; const off = 20; const nn = []; const ne = []; const ns = [];
                    state.clipboard.nodes.forEach(n => {
                        const nid = uuid(); idMap[n.id] = nid;
                        nn.push({ ...n, id: nid, x: n.x + off, y: n.y + off }); ns.push(nid);
                    });
                    state.clipboard.edges.forEach(e => {
                        if (idMap[e.source] && idMap[e.target]) ne.push({ ...e, id: uuid(), source: idMap[e.source], target: idMap[e.target] });
                    });
                    state.nodes.push(...nn); state.edges.push(...ne); state.selection = ns; saveState(); render(); showToast('Ë≤º„Çä‰ªò„Åë„Åæ„Åó„Åü');
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
        });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') wrapperEl.style.cursor = 'default'; });

        window.addEventListener('mouseup', (e) => {
            if (!state.isDragging) return;
            if (state.dragTarget === 'port') {
                state.tempLine.remove();
                const el = document.elementFromPoint(e.clientX, e.clientY);
                if (el && el.classList.contains('port')) {
                    const tId = el.dataset.nodeId; const tDir = el.dataset.dir;
                    if (tId && tId !== state.dragStart.nodeId) {
                        state.edges.push({ id: uuid(), source: state.dragStart.nodeId, sourcePort: state.dragStart.portDir, target: tId, targetPort: tDir, label: '', marker: 'end' });
                        saveState();
                    }
                }
            } else if (state.dragTarget === 'rubberband') {
                const r = state.rubberbandRect;
                const rx = parseFloat(r.getAttribute('x')); const ry = parseFloat(r.getAttribute('y'));
                const rw = parseFloat(r.getAttribute('width')); const rh = parseFloat(r.getAttribute('height'));
                state.nodes.forEach(n => {
                    if (n.x < rx + rw && n.x + n.w > rx && n.y < ry + rh && n.y + n.h > ry) { if (!state.selection.includes(n.id)) state.selection.push(n.id); }
                });
                state.rubberbandRect.remove(); updatePropsPanel();
            } else if (['node', 'resize'].includes(state.dragTarget)) { saveState(); }
            if (state.dragTarget === 'pan') wrapperEl.style.cursor = 'default';
            state.isDragging = false; state.dragTarget = null; render();
        });

        // DND
        const dndItems = document.querySelectorAll('.dnd-item');
        dndItems.forEach(item => item.addEventListener('dragstart', (e) => e.dataTransfer.setData('type', item.dataset.type)));
        wrapperEl.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
        wrapperEl.addEventListener('drop', (e) => {
            e.preventDefault(); const type = e.dataTransfer.getData('type'); if (!type) return;
            const pos = getMousePos(e);
            let w = 120, h = 60, lbl = 'Âá¶ÁêÜ', bg = '#ffffff';
            if (type === 'circle') { w = 60; h = 60; lbl = 'ÈñãÂßã'; }
            else if (type === 'diamond') { w = 80; h = 80; lbl = '?'; }
            else if (type === 'db') { w = 60; h = 60; lbl = 'DB'; }
            else if (type === 'swimlane') { w = 300; h = 400; lbl = 'ÊãÖÂΩìÈ†òÂüü'; bg = '#f8fafc'; }
            else if (type === 'text') { w = 120; h = 40; lbl = '„ÉÜ„Ç≠„Çπ„Éà'; bg = 'transparent'; }
            const newNode = { id: uuid(), type: type, x: snap(pos.x - w / 2), y: snap(pos.y - h / 2), w: w, h: h, label: lbl, bgColor: bg, strokeWidth: 2 };
            state.nodes.push(newNode); saveState(); state.selection = [newNode.id]; render();
        });

        // Export & Init
        const btnExportMenu = document.getElementById('btn-export-menu');
        btnExportMenu.addEventListener('click', (e) => { e.stopPropagation(); exportMenu.style.display = exportMenu.style.display === 'flex' ? 'none' : 'flex'; });
        window.addEventListener('click', (e) => { if (!e.target.closest('#btn-export-menu')) exportMenu.style.display = 'none'; });

        document.getElementById('export-json').addEventListener('click', () => {
            const b = new Blob([JSON.stringify({ nodes: state.nodes, edges: state.edges }, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `bizflow_${Date.now()}.json`; a.click();
        });

        document.getElementById('export-pdf').addEventListener('click', () => {
            if (state.nodes.length === 0) return alert('„Ç≠„É£„É≥„Éê„Çπ„ÅåÁ©∫„Åß„Åô');
            const originalZoom = state.zoom; const originalPan = { ...state.pan };
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(n => { if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y; if (n.x + n.w > maxX) maxX = n.x + n.w; if (n.y + n.h > maxY) maxY = n.y + n.h; });
            const padding = 20; state.pan.x = -minX + padding; state.pan.y = -minY + padding; state.zoom = 1;
            render(); setTimeout(() => { window.print(); state.pan = originalPan; state.zoom = originalZoom; render(); }, 100);
        });

        function exportImage(format) {
            exportMenu.style.display = 'none';
            if (state.nodes.length === 0) return alert('„Ç≠„É£„É≥„Éê„Çπ„ÅåÁ©∫„Åß„Åô');
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(n => { if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y; if (n.x + n.w > maxX) maxX = n.x + n.w; if (n.y + n.h > maxY) maxY = n.y + n.h; });
            const padding = 50; const width = maxX - minX + padding * 2; const height = maxY - minY + padding * 2;
            const clone = svgEl.cloneNode(true);
            const viewport = clone.getElementById('viewport-group');
            viewport.setAttribute('transform', `translate(${padding - minX}, ${padding - minY})`);
            clone.setAttribute('width', width); clone.setAttribute('height', height);
            clone.querySelectorAll('.port, .resize-handle, #layer-ui').forEach(el => el.remove());
            const isPng = format === 'image/png';
            const bgColor = isPng ? 'transparent' : '#f0f0f0';
            clone.style.background = bgColor;
            const style = document.createElement('style');
            style.textContent = `.node-body { stroke: #1e293b; vector-effect: non-scaling-stroke; } .connector-path { fill: none; stroke: #64748b; stroke-width: 2px; stroke-linejoin: round; stroke-linecap: round; } .node-label, .edge-label-text { font-family: sans-serif; font-size: 14px; fill: #334155; } .text-bg-rect { fill-opacity: 1; stroke: none; }`;
            clone.insertBefore(style, clone.firstChild);
            const svgData = new XMLSerializer().serializeToString(clone);
            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d');
                if (!isPng) { ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.beginPath(); for (let x = 0; x <= width; x += 20) { ctx.moveTo(x, 0); ctx.lineTo(x, height); } for (let y = 0; y <= height; y += 20) { ctx.moveTo(0, y); ctx.lineTo(width, y); } ctx.stroke(); }
                ctx.drawImage(img, 0, 0);
                const a = document.createElement('a'); a.href = canvas.toDataURL(format); a.download = `bizflow_${Date.now()}.${isPng ? 'png' : 'jpg'}`; a.click();
            };
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }
        document.getElementById('export-png').addEventListener('click', () => exportImage('image/png'));
        document.getElementById('export-jpeg').addEventListener('click', () => exportImage('image/jpeg'));

        document.getElementById('btn-import').addEventListener('click', () => document.getElementById('file-input').click());
        document.getElementById('file-input').addEventListener('change', (e) => {
            const f = e.target.files[0]; if (!f) return;
            const r = new FileReader(); r.onload = (ev) => { try { const d = JSON.parse(ev.target.result); state.nodes = d.nodes; state.edges = d.edges; state.selection = []; saveState(); render(); } catch (err) { alert('Ë™≠„ÅøËæº„Åø„Ç®„É©„Éº'); } };
            r.readAsText(f);
        });

        window.addEventListener('DOMContentLoaded', () => {
            try {
                const s = localStorage.getItem(STORAGE_KEY);
                if (s) { state.history.push(s); state.historyIndex = 0; restore(s); } else saveState();
            } catch (e) { console.error('Storage Error', e); saveState(); }
            render();
        });
    </script>
</body>

</html>
