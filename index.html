<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BizFlow Designer (v7.4 Improved)</title>
    <style>
        /* =========================================
           CSS Reset & Variables
           ========================================= */
        :root {
            --bg-color: #f0f0f0;
            --panel-bg: #ffffff;
            --border-color: #e2e8f0;
            --text-main: #334155;
            --text-muted: #64748b;
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --grid-color: #cbd5e1;
            --selection-color: #3b82f6;
            --drag-placeholder: #eff6ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Yu Gothic UI', 'Meiryo', sans-serif;
            color: var(--text-main);
            height: 100vh;
            overflow: hidden;
            background-color: var(--bg-color);
            user-select: none;
            touch-action: none;
            /* ブラウザ標準のタッチ操作を無効化 */
        }

        /* =========================================
           Layout
           ========================================= */
        .app-container {
            display: grid;
            grid-template-columns: 240px 1fr 280px;
            height: 100%;
            width: 100%;
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .h-full {
            height: 100%;
        }

        .overflow-hidden {
            overflow: hidden;
        }

        .items-center {
            align-items: center;
        }

        .gap-2 {
            gap: 0.5rem;
        }

        .p-4 {
            padding: 1rem;
        }

        .border-b {
            border-bottom: 1px solid var(--border-color);
        }

        .border-r {
            border-right: 1px solid var(--border-color);
        }

        .border-l {
            border-left: 1px solid var(--border-color);
        }

        .border-t {
            border-top: 1px solid var(--border-color);
        }

        /* =========================================
           Left Panel (Stencil)
           ========================================= */
        .panel-header {
            background-color: #f8fafc;
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
        }

        .app-title {
            font-size: 1.125rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .app-subtitle {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 0.25rem;
        }

        .stencil-content {
            overflow-y: auto;
            flex: 1;
            padding: 1rem;
            background: var(--panel-bg);
            min-height: 0;
        }

        .group-title {
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            margin-top: 1rem;
        }

        .group-title:first-child {
            margin-top: 0;
        }

        .dnd-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            background: white;
            cursor: grab;
            transition: all 0.2s;
            margin-bottom: 0.75rem;
        }

        .dnd-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-color);
        }

        .dnd-item:active {
            cursor: grabbing;
        }

        .shape-preview {
            border: 2px solid #1e293b;
            background: white;
            box-sizing: border-box;
        }

        .shape-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
        }

        .shape-rect {
            width: 64px;
            height: 40px;
            border-radius: 6px;
        }

        .shape-diamond {
            width: 40px;
            height: 40px;
            transform: rotate(45deg) scale(0.8);
            margin: 4px;
        }

        .svg-icon-container {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #334155;
        }

        .svg-icon-container svg {
            width: 100%;
            height: 100%;
            overflow: visible;
            fill: currentColor;
        }

        .shape-swimlane {
            width: 64px;
            height: 48px;
            border: 2px solid #1e293b;
            border-top-width: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .swimlane-line {
            width: 100%;
            height: 1px;
            background: #cbd5e1;
        }

        .shape-text {
            width: 64px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px dashed #cbd5e1;
            background: transparent;
            font-size: 20px;
            font-weight: bold;
            color: #1e293b;
        }

        .item-label {
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 0.5rem;
        }

        /* =========================================
           Center Panel (Canvas)
           ========================================= */
        .toolbar {
            height: 48px;
            background: var(--panel-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 1rem;
            z-index: 10;
            position: relative;
            flex-shrink: 0;
            overflow-x: auto;
            /* 横スクロール対応 */
            white-space: nowrap;
        }

        /* スクロールバーのスタイル調整 */
        .toolbar::-webkit-scrollbar {
            height: 4px;
        }

        .toolbar::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 2px;
        }

        .btn-icon {
            background: none;
            border: none;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            color: var(--text-main);
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .btn-icon:hover:not(:disabled) {
            background-color: #f1f5f9;
        }

        .btn-icon:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .btn-icon svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .separator {
            width: 1px;
            height: 24px;
            background: var(--border-color);
            margin: 0 0.5rem;
            flex-shrink: 0;
        }

        .btn-text {
            padding: 6px 12px;
            font-size: 0.875rem;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid transparent;
            position: relative;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--primary-hover);
        }

        .btn-secondary {
            color: var(--text-main);
            border-color: var(--border-color);
            background: white;
        }

        .btn-secondary:hover {
            background-color: #f8fafc;
        }

        .btn-danger {
            color: #dc2626;
        }

        .btn-danger:hover {
            background-color: #fef2f2;
        }

        /* AI Button Style */
        .btn-ai-prompt {
            background: linear-gradient(135deg, #8b5cf6, #d946ef);
            color: white;
            border: none;
            font-weight: bold;
            box-shadow: 0 2px 4px rgba(139, 92, 246, 0.3);
            transition: transform 0.1s, box-shadow 0.1s;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .btn-ai-prompt:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(139, 92, 246, 0.4);
            opacity: 0.95;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
            background-color: var(--bg-color);
            overflow: hidden;
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: default;
        }

        svg {
            display: block;
            overflow: visible;
        }

        .node-group {
            cursor: move;
        }

        .node-body {
            stroke: #1e293b;
            vector-effect: non-scaling-stroke;
        }

        .node-label {
            pointer-events: none;
            font-family: sans-serif;
        }

        .edge-label-text {
            font-size: 12px;
            fill: #475569;
            font-family: sans-serif;
            pointer-events: none;
        }

        .text-bg-rect {
            fill-opacity: 0.9;
            stroke: none;
            rx: 2px;
        }

        .connector-path {
            fill: none;
            stroke: #64748b;
            stroke-width: 2px;
            stroke-linejoin: round;
            stroke-linecap: round;
            pointer-events: stroke;
            cursor: pointer;
        }

        .connector-path:hover {
            stroke: var(--primary-color);
            stroke-width: 3px !important;
        }

        .connector-path.selected {
            stroke: var(--primary-color);
            stroke-width: 3px !important;
        }

        /* ポートスタイルの改善 */
        .port {
            fill: white;
            stroke: var(--primary-color);
            stroke-width: 1px;
            r: 3.5px;
            /* 少し小さくして密集に対応 */
            cursor: crosshair;
            opacity: 0;
            transition: opacity 0.2s, r 0.1s;
        }

        .node-group:hover .port {
            opacity: 1;
        }

        .port:hover {
            fill: var(--primary-color);
            r: 6px;
            opacity: 1;
        }

        .selected .node-body {
            stroke: var(--primary-color);
            stroke-dasharray: 5 5;
        }

        .selected.text-node .node-label {
            fill: var(--primary-color);
            text-decoration: underline;
        }

        .resize-handle {
            width: 10px;
            height: 10px;
            fill: var(--primary-color);
            stroke: white;
            stroke-width: 1px;
            cursor: nwse-resize;
            display: none;
        }

        /* エッジルート調整用のハンドル */
        .edge-handle {
            fill: var(--primary-color);
            stroke: white;
            stroke-width: 1px;
            r: 5px;
            cursor: move;
            display: none;
            opacity: 0.8;
        }

        .edge-handle:hover {
            r: 7px;
            opacity: 1;
        }

        .node-group.selected .resize-handle {
            display: block;
        }

        .rubberband {
            fill: rgba(59, 130, 246, 0.1);
            stroke: #3b82f6;
            stroke-width: 1px;
            pointer-events: none;
        }

        /* Quick Add Handle */
        .quick-add-handle {
            fill: #fff;
            stroke: var(--primary-color);
            stroke-width: 1px;
            cursor: pointer;
            opacity: 0.9;
            transition: all 0.2s;
        }

        .quick-add-handle:hover {
            fill: var(--primary-color);
            opacity: 1;
        }

        .quick-add-symbol {
            pointer-events: none;
            stroke: var(--primary-color);
            stroke-width: 2px;
            stroke-linecap: round;
        }

        .quick-add-group:hover .quick-add-symbol {
            stroke: white;
        }

        /* =========================================
           Right Panel (Tabs & Content)
           ========================================= */
        .properties-panel {
            background: var(--panel-bg);
            display: flex;
            flex-direction: column;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background: #f8fafc;
            flex-shrink: 0;
        }

        .tab-btn {
            flex: 1;
            padding: 0.75rem;
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            border: none;
            background: none;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }

        .tab-btn:hover {
            color: var(--primary-color);
            background: #f1f5f9;
        }

        .tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background: white;
        }

        .panel-content {
            display: none;
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            min-height: 0;
        }

        .panel-content.active {
            display: block;
        }

        .prop-group {
            margin-bottom: 1rem;
        }

        .prop-label {
            display: block;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .prop-input {
            width: 100%;
            padding: 0.5rem;
            font-size: 0.875rem;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            outline: none;
        }

        .prop-input:focus {
            border-color: var(--primary-color);
        }

        .color-picker-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        /* Palette Styles */
        .color-palette {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 4px;
            margin-top: 0.5rem;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid #e2e8f0;
            transition: transform 0.1s;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: var(--text-muted);
        }

        .dimension-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .layer-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .layer-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px;
            margin-bottom: 4px;
            border: 1px solid var(--border-color);
            background: white;
            border-radius: 4px;
            cursor: grab;
            font-size: 0.8rem;
        }

        .layer-item:hover {
            border-color: var(--primary-color);
        }

        .layer-item:active {
            cursor: grabbing;
        }

        .layer-item.dragging {
            opacity: 0.5;
            background: var(--drag-placeholder);
        }

        .layer-item-content {
            display: flex;
            align-items: center;
            gap: 8px;
            flex: 1;
            overflow: hidden;
        }

        .layer-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .layer-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .layer-handle {
            color: #cbd5e1;
            cursor: grab;
        }

        #quick-add-menu {
            position: absolute;
            background: white;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            padding: 8px;
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            z-index: 100;
        }

        .quick-add-item {
            width: 40px;
            height: 40px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .quick-add-item:hover {
            background-color: #f1f5f9;
            border-color: var(--primary-color);
        }

        /* UPDATE: Export Menu Fixed Positioning */
        #export-menu {
            position: fixed;
            /* absolute -> fixed */
            top: 0;
            left: 0;
            margin-top: 0;
            background: white;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border-radius: 4px;
            width: 180px;
            display: none;
            flex-direction: column;
            z-index: 1000;
            /* ツールバーより確実に上に */
        }

        .export-item {
            padding: 8px 12px;
            text-align: left;
            font-size: 0.875rem;
            color: var(--text-main);
            background: none;
            border: none;
            cursor: pointer;
        }

        .export-item:hover {
            background-color: #f1f5f9;
        }

        #toast {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            background: #1e293b;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-size: 0.875rem;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 200;
        }

        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .modal-content {
            background: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 600px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .modal-textarea {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #444;
            /* Darker border */
            border-radius: 4px;
            font-family: 'Consolas', 'Monaco', monospace;
            /* Monospace font */
            font-size: 0.9rem;
            resize: vertical;
            background-color: #1e1e1e;
            /* Dark background */
            color: #f0f0f0;
            /* Light text */
        }

        /* Improved Instruction Box Style */
        .instruction-box {
            background-color: #eff6ff;
            /* Light blue background */
            border-left: 4px solid #3b82f6;
            /* Accent border */
            padding: 12px 16px;
            border-radius: 4px;
            margin-bottom: 15px;
            color: #1e293b;
            font-size: 0.85rem;
            line-height: 1.6;
        }

        .instruction-step {
            display: flex;
            margin-bottom: 6px;
            align-items: baseline;
        }

        .instruction-step-num {
            font-weight: bold;
            color: #3b82f6;
            margin-right: 8px;
            flex-shrink: 0;
        }

        .instruction-highlight {
            font-weight: bold;
            color: #1d4ed8;
            background: #dbeafe;
            padding: 0 4px;
            border-radius: 2px;
        }

        /* Print */
        @media print {
            @page {
                size: auto;
                margin: 0mm;
            }

            body {
                background: white;
                overflow: visible;
                margin: 0;
                padding: 0;
            }

            .app-container {
                display: block;
                height: auto;
                width: 100%;
            }

            .flex-col.border-r,
            .properties-panel,
            .toolbar,
            #toast,
            #quick-add-menu,
            #export-menu,
            #ai-prompt-modal {
                display: none !important;
            }

            #canvas-wrapper {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                overflow: visible;
                background: none;
                border: none;
                margin: 0;
            }

            svg#main-svg {
                width: 100%;
                height: 100%;
                overflow: visible;
                background-color: white;
            }

            #bg-rect {
                fill: white !important;
            }

            pattern#grid-pattern path {
                stroke: none !important;
            }

            .port,
            .resize-handle,
            .rubberband,
            #layer-ui {
                display: none !important;
            }
        }
    </style>
</head>

<body>

    <div class="app-container">
        <!-- LEFT PANEL -->
        <div class="flex flex-col border-r shadow-sm z-10 h-full overflow-hidden">
            <div class="panel-header">
                <div class="app-title">
                    <svg width="24" height="24" viewBox="0 0 256 256" fill="#3b82f6">
                        <path
                            d="M200,168a32,32,0,0,0-30.37,22.18L130.3,109.84a8,8,0,0,0-12.6,0l-39.33,80.34A32,32,0,1,0,88,200a31.86,31.86,0,0,0-2.34-12l35.8-73.13,35.8,73.13A31.86,31.86,0,0,0,152,200a32,32,0,1,0,48-32Zm-144,48a16,16,0,1,1,16-16A16,16,0,0,1,56,216Zm96,0a16,16,0,1,1,16-16A16,16,0,0,1,152,216Zm48,0a16,16,0,1,1,16-16A16,16,0,0,1,200,216ZM96,64A32,32,0,1,1,64,32,32,32,0,0,1,96,64Zm8,53.48-18.1-37A47.85,47.85,0,0,0,128,112a47.85,47.85,0,0,0,42.1-31.54l-18.1,37A32,32,0,0,1,104,117.48ZM64,80a16,16,0,1,0-16-16A16,16,0,0,0,64,80Z">
                        </path>
                    </svg>
                    BizFlow
                </div>
                <div class="app-subtitle">アクティビティ図作成ツール (v7.4)</div>
            </div>

            <div class="stencil-content">
                <div class="group-title">ノード</div>
                <div class="dnd-item" draggable="true" data-type="circle" title="開始/終了">
                    <div class="shape-preview shape-circle"></div>
                    <span class="item-label">開始 / 終了</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="rect" title="処理">
                    <div class="shape-preview shape-rect"></div>
                    <span class="item-label">処理</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="diamond" title="判断">
                    <div class="shape-preview shape-diamond"></div>
                    <span class="item-label">判断</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="db" title="データストア">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 40 40">
                            <path
                                d="M 0 6 A 20 6 0 1 1 40 6 A 20 6 0 1 1 0 6 z M 0 6 L 0 34 A 20 6 0 0 0 40 34 L 40 6 A 20 6 0 0 1 0 6"
                                fill="white" stroke="#1e293b" stroke-width="2"></path>
                        </svg>
                    </div>
                    <span class="item-label">データストア</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="text" title="テキスト">
                    <div class="shape-text">T</div>
                    <span class="item-label">テキスト</span>
                </div>

                <!-- アイコン -->
                <div class="group-title">アイコン (改良版)</div>
                <div class="dnd-item" draggable="true" data-type="icon-pc" title="パソコン">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M20 17.575V4H4V17.575H20ZM22 2V19H13V21H16V23H8V21H11V19H2V2H22ZM6 6H18V15.5H6V6Z" />
                            <rect x="6" y="6" width="12" height="9.5" fill="currentColor" />
                        </svg>
                    </div>
                    <span class="item-label">パソコン</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="icon-doc" title="書類">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2ZM13 9V3.5L18.5 9H13Z" />
                        </svg>
                    </div>
                    <span class="item-label">書類</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="icon-server" title="サーバー">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path d="M2 20V4H22V20H2ZM4 6V10H20V6H4ZM4 12V18H20V12H4ZM6 7V9H8V7H6ZM6 13V15H8V13H6Z" />
                        </svg>
                    </div>
                    <span class="item-label">サーバー</span>
                </div>
                <div class="dnd-item" draggable="true" data-type="icon-user" title="ユーザー">
                    <div class="svg-icon-container">
                        <svg viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z" />
                        </svg>
                    </div>
                    <span class="item-label">ユーザー</span>
                </div>

                <div class="group-title">コンテナ</div>
                <div class="dnd-item" draggable="true" data-type="swimlane" title="担当領域">
                    <div class="shape-preview shape-swimlane">
                        <div class="swimlane-line"></div>
                    </div>
                    <span class="item-label">担当領域</span>
                </div>
                <div style="height: 50px;"></div>
            </div>
        </div>

        <!-- CENTER PANEL -->
        <div class="flex flex-col relative overflow-hidden h-full">
            <div class="toolbar">
                <div class="flex items-center gap-2">
                    <button id="btn-undo" class="btn-icon" title="元に戻す (Ctrl+Z)" disabled><svg viewBox="0 0 24 24">
                            <path
                                d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z">
                            </path>
                        </svg></button>
                    <button id="btn-redo" class="btn-icon" title="やり直し (Ctrl+Y)" disabled><svg viewBox="0 0 24 24">
                            <path
                                d="M18.4 10.6C16.55 9 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z">
                            </path>
                        </svg></button>
                    <div class="separator"></div>
                    <button id="btn-home" class="btn-icon" title="元の位置に戻る"><svg viewBox="0 0 24 24">
                            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z" />
                        </svg></button>
                    <button id="btn-fit" class="btn-icon" title="大きさを100%に戻す"><svg viewBox="0 0 24 24">
                            <path
                                d="M15 3l2.3 2.3-2.89 2.87 1.42 1.42L18.7 6.7 21 9V3zM3 9l2.3-2.3 2.87 2.89 1.42-1.42L6.7 5.3 9 3H3zm6 12l-2.3-2.3 2.89-2.87-1.42-1.42L5.3 17.3 3 15v6zm12-6l-2.3 2.3-2.87-2.89-1.42 1.42 2.89 2.87L15 21h6z">
                            </path>
                        </svg></button>
                    <div class="separator"></div>
                    <button id="btn-zoom-out" class="btn-icon" title="縮小"><svg viewBox="0 0 24 24">
                            <path d="M19 13H5v-2h14v2z"></path>
                        </svg></button>
                    <span id="zoom-level"
                        style="font-size: 0.875rem; font-family: monospace; width: 48px; text-align: center;">100%</span>
                    <button id="btn-zoom-in" class="btn-icon" title="拡大"><svg viewBox="0 0 24 24">
                            <path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path>
                        </svg></button>
                </div>
                <div class="flex items-center gap-2">
                    <button id="btn-ai-prompt" class="btn-text btn-ai-prompt">✨ AIを使って作成</button>
                    <div class="separator"></div>
                    <button id="btn-clear" class="btn-text btn-danger">全削除</button>
                    <div class="separator"></div>
                    <button id="btn-import" class="btn-text btn-secondary">JSONから読込</button>

                    <div style="position: relative;">
                        <button id="btn-export-menu" class="btn-text btn-primary">保存 ▼</button>
                        <!-- Export menu will be positioned by JS -->
                    </div>
                </div>
            </div>

            <!-- Export Menu (Moved out of toolbar flow visually, though structurally here, CSS makes it fixed) -->
            <div id="export-menu">
                <button class="export-item" id="export-json">JSONファイルとして保存</button>
                <button class="export-item" id="export-png">PNG画像 (背景透過)</button>
                <button class="export-item" id="export-jpeg">JPEG画像 (背景あり)</button>
                <button class="export-item" id="export-svg">SVG形式で保存 (New)</button>
                <button class="export-item" id="export-pdf">PDF印刷 / 保存</button>
            </div>

            <div id="canvas-wrapper">
                <svg id="main-svg" width="100%" height="100%">
                    <defs>
                        <pattern id="grid-pattern" width="20" height="20" patternUnits="userSpaceOnUse">
                            <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#e2e8f0" stroke-width="1" />
                        </pattern>
                        <marker id="arrow-end" markerWidth="7" markerHeight="7" refX="6" refY="3.5" orient="auto"
                            markerUnits="strokeWidth">
                            <path d="M0,0 L0,7 L7,3.5 z" fill="#64748b" />
                        </marker>
                        <marker id="arrow-start" markerWidth="7" markerHeight="7" refX="1" refY="3.5" orient="auto"
                            markerUnits="strokeWidth">
                            <path d="M7,0 L7,7 L0,3.5 z" fill="#64748b" />
                        </marker>
                    </defs>
                    <rect id="bg-rect" width="100%" height="100%" fill="none"></rect>
                    <g id="viewport-group">
                        <g id="layer-swimlanes"></g>
                        <g id="layer-edges"></g>
                        <g id="layer-nodes"></g>
                        <g id="layer-labels"></g>
                        <g id="layer-ui"></g>
                    </g>
                </svg>
            </div>

            <div id="quick-add-menu">
                <div class="quick-add-item" data-type="rect" title="処理を追加">
                    <div class="shape-preview shape-rect" style="width:24px; height:16px;"></div>
                </div>
                <div class="quick-add-item" data-type="diamond" title="判断を追加">
                    <div class="shape-preview shape-diamond" style="width:20px; height:20px;"></div>
                </div>
                <div class="quick-add-item" data-type="db" title="DBを追加">
                    <div class="svg-icon-container" style="transform: scale(0.6);">
                        <svg viewBox="0 0 40 40">
                            <path
                                d="M 0 6 A 20 6 0 1 1 40 6 A 20 6 0 1 1 0 6 z M 0 6 L 0 34 A 20 6 0 0 0 40 34 L 40 6 A 20 6 0 0 1 0 6"
                                fill="white" stroke="#1e293b" stroke-width="2"></path>
                        </svg>
                    </div>
                </div>
                <div class="quick-add-item" data-type="circle" title="終了を追加">
                    <div class="shape-preview shape-circle" style="width:20px; height:20px;"></div>
                </div>
            </div>

            <div id="toast">保存しました</div>
        </div>

        <!-- RIGHT PANEL -->
        <div class="properties-panel border-l z-10 h-full overflow-hidden">
            <!-- Tabs -->
            <div class="tabs">
                <button class="tab-btn active" data-tab="prop">プロパティ</button>
                <button class="tab-btn" data-tab="layer">レイヤー</button>
            </div>

            <!-- Property Tab -->
            <div id="tab-prop" class="panel-content active">
                <div id="props-empty"
                    style="text-align: center; color: var(--text-muted); font-style: italic; margin-top: 2rem;">
                    要素を選択すると<br>詳細が表示されます
                </div>
                <div id="props-multi"
                    style="text-align: center; color: var(--text-muted); font-style: italic; margin-top: 2rem; display: none;">
                    複数項目を選択中
                </div>
                <div id="props-content" style="display: none;">
                    <!-- Node Specific -->
                    <div id="group-node-type" class="prop-group">
                        <label class="prop-label">種類 (Type)</label>
                        <select id="prop-type" class="prop-input">
                            <option value="rect">処理 (Action)</option>
                            <option value="circle">開始/終了 (Circle)</option>
                            <option value="diamond">判断 (Decision)</option>
                            <option value="db">データストア (DB)</option>
                            <option value="text">テキスト (Text)</option>
                            <option value="swimlane">担当領域 (Swimlane)</option>
                            <option value="icon-pc">アイコン: PC</option>
                            <option value="icon-doc">アイコン: 書類</option>
                            <option value="icon-server">アイコン: サーバー</option>
                            <option value="icon-user">アイコン: ユーザー</option>
                        </select>
                    </div>
                    <div id="group-edge-style" class="prop-group" style="display:none;">
                        <label class="prop-label">マーカー (矢印)</label>
                        <select id="prop-edge-marker" class="prop-input">
                            <option value="none">なし</option>
                            <option value="end">終了点のみ (→)</option>
                            <option value="start">開始点のみ (←)</option>
                            <option value="both">両端 (↔)</option>
                        </select>
                        <div style="margin-top: 10px; font-size: 0.75rem; color: #64748b;">
                            ※ 線上の青いハンドルをドラッグすると経路を調整できます。ダブルクリックでリセットします。
                        </div>
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">ID</label>
                        <input type="text" id="prop-id" class="prop-input" readonly
                            style="background: #f1f5f9; font-family: monospace;">
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">ラベルテキスト</label>
                        <textarea id="prop-label" rows="3" class="prop-input"></textarea>
                    </div>
                    <div class="prop-group">
                        <label class="prop-label">フォント設定</label>
                        <div class="dimension-inputs">
                            <div>
                                <label style="font-size: 0.7rem; color: #94a3b8;">サイズ (px)</label>
                                <input type="number" id="prop-font-size" class="prop-input" min="8" max="72">
                            </div>
                            <div>
                                <label style="font-size: 0.7rem; color: #94a3b8;">色</label>
                                <input type="color" id="prop-text-color"
                                    style="width: 100%; height: 34px; cursor: pointer;">
                            </div>
                        </div>
                        <div style="margin-top:0.5rem;">
                            <label style="font-size: 0.7rem; color: #94a3b8;">テキスト背景</label>
                            <div class="color-picker-row">
                                <input type="color" id="prop-text-bg-color"
                                    style="height: 32px; width: 64px; cursor: pointer;">
                                <button id="btn-text-bg-none" class="btn-text btn-secondary"
                                    style="font-size: 0.75rem;">なし</button>
                            </div>
                        </div>
                    </div>
                    <div class="prop-group" id="group-dimensions">
                        <label class="prop-label">サイズ</label>
                        <div class="dimension-inputs">
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">幅 (W)</label><input type="number"
                                    id="prop-w" class="prop-input"></div>
                            <div><label style="font-size: 0.7rem; color: #94a3b8;">高さ (H)</label><input type="number"
                                    id="prop-h" class="prop-input"></div>
                        </div>
                    </div>
                    <div class="prop-group" id="group-style">
                        <label class="prop-label">スタイル</label>
                        <div style="margin-bottom: 0.5rem;">
                            <label style="font-size: 0.7rem; color: #94a3b8;">枠線太さ (px)</label>
                            <input type="number" id="prop-stroke-width" class="prop-input" min="0" max="10" step="0.5"
                                value="2">
                        </div>
                        <div>
                            <label style="font-size: 0.7rem; color: #94a3b8;">図形背景色</label>
                            <div class="color-picker-row">
                                <input type="color" id="prop-color" style="height: 32px; width: 64px; cursor: pointer;">
                                <button id="btn-reset-color" class="btn-text btn-secondary"
                                    style="font-size: 0.75rem;">リセット</button>
                            </div>
                            <div class="color-palette" id="color-palette">
                                <div class="color-swatch" style="background: #fee2e2;" data-color="#fee2e2"
                                    title="Red 100"></div>
                                <div class="color-swatch" style="background: #ffedd5;" data-color="#ffedd5"
                                    title="Orange 100"></div>
                                <div class="color-swatch" style="background: #fef9c3;" data-color="#fef9c3"
                                    title="Yellow 100"></div>
                                <div class="color-swatch" style="background: #dcfce7;" data-color="#dcfce7"
                                    title="Green 100"></div>
                                <div class="color-swatch" style="background: #dbeafe;" data-color="#dbeafe"
                                    title="Blue 100"></div>
                                <div class="color-swatch" style="background: #e0e7ff;" data-color="#e0e7ff"
                                    title="Indigo 100"></div>
                                <div class="color-swatch" style="background: #f3e8ff;" data-color="#f3e8ff"
                                    title="Purple 100"></div>
                                <div class="color-swatch" style="background: #fae8ff;" data-color="#fae8ff"
                                    title="Fuchsia 100"></div>
                                <div class="color-swatch" style="background: #ffe4e6;" data-color="#ffe4e6"
                                    title="Rose 100"></div>
                                <div class="color-swatch" style="background: #f1f5f9;" data-color="#f1f5f9"
                                    title="Slate 100"></div>
                            </div>
                        </div>
                    </div>
                    <div style="height: 50px;"></div>
                </div>
            </div>

            <!-- Layer Tab -->
            <div id="tab-layer" class="panel-content">
                <div style="font-size:0.75rem; color:#64748b; margin-bottom:0.5rem;">上にある項目が手前に表示されます。<br>ドラッグで順序変更可能です。
                </div>
                <ul id="layer-list" class="layer-list"></ul>
            </div>
        </div>
    </div>

    <!-- AI Prompt Modal -->
    <div id="ai-prompt-modal" class="modal-overlay">
        <div class="modal-content">
            <h3 style="margin-bottom: 10px; font-weight: bold; color: #334155;">AIプロンプト作成テンプレート</h3>

            <div class="instruction-box">
                <div class="instruction-step">
                    <span class="instruction-step-num">1.</span>
                    <span>下の黒い画面にある <span class="instruction-highlight">{{{{{ここに業務フローの内容を記述}}}}}</span>
                        の部分を、実際の業務内容（例：メールを受信したら確認する等）に書き換えてください。</span>
                </div>
                <div class="instruction-step">
                    <span class="instruction-step-num">2.</span>
                    <span>書き換えたら全文をコピーし、ChatGPTなどのAIに貼り付けて指示を出してください。</span>
                </div>
                <div class="instruction-step">
                    <span class="instruction-step-num">3.</span>
                    <span>AIが作成したコードを <span class="instruction-highlight">.json</span> という拡張子（例:
                        flow.json）でPCに保存してください。</span>
                </div>
                <div class="instruction-step">
                    <span class="instruction-step-num">4.</span>
                    <span>この画面上部の「JSONから読込」ボタンから、保存したファイルを読み込んでください。</span>
                </div>
            </div>

            <textarea id="ai-prompt-text" class="modal-textarea">
# **業務フローの内容**

{{{{{ここに業務フローの内容を記述}}}}} (例：社内のPCセットアップ業務。管理者がPCを準備し、ユーザーに書類を渡す。その後ユーザーが受領確認を行う。)

# **命令**

あなたは業務フロー図作成ツール「BizFlow Designer」のデータ生成エンジンです。 上記の【業務フローの内容】を読み解き、定義された【JSONフォーマット仕様】に厳密に従ってJSONデータを出力してください。

# **制約条件とルール**

1. **座標計算（重要）**:  
   * 各ノードは重ならないように配置すること。  
   * 業務の流れに従って、**左から右へ**、または**上から下へ**順序よく座標(x, y)を計算して設定すること。  
   * 座標は `x: 0, y: 0` から `x: 800, y: 600` 程度の範囲に収めること。  
2. **配線の最適化（重要）**:  
   * 複数の接続線が特定の図形に集中する場合、線が重なって視認性が落ちるのを防ぐため、後述する\*\*拡張ポート（`top-L`, `top-R`など）\*\*を積極的に使い分けること。  
3. **ID**: 全てユニークな文字列にすること（例: `node_1`, `edge_1`）。  
4. **JSON形式**: 出力はJSONデータのみとすること（解説不要）。

# **JSONフォーマット仕様**

以下の仕様に従ってください。

## **1\. ノード定義 (nodes)**

各図形は以下のプロパティを持ちます。

* `type`: 図形の種類（以下のリストから適切なものを選択）  
  * `circle`: 開始 / 終了 (サイズ推奨: w:60, h:60)  
  * `rect`: 処理 (サイズ推奨: w:120, h:60)  
  * `diamond`: 判断 (サイズ推奨: w:80, h:80)  
  * `db`: データストア (サイズ推奨: w:60, h:60)  
  * `swimlane`: 担当領域/スイムレーン (サイズ推奨: w:300\~600, h:400)  
  * `text`: テキストメモ  
  * `icon-pc`: PCアイコン  
  * `icon-doc`: 書類アイコン  
  * `icon-server`: サーバーアイコン  
  * `icon-user`: ユーザーアイコン  
* `x`, `y`: 配置座標 (数値)  
* `w`, `h`: 幅と高さ (数値)  
  * **注記**: 上記の推奨サイズはあくまで目安です。ラベルの文字数が多い場合や、レイアウトの規模・内容に応じて、**視認しやすいサイズに適宜変更・拡大しても構いません**。  
* `label`: 表示するテキスト (改行は `\n`)  
* `bgColor`: 背景色 (任意。例: `#ffffff`, `#dbeafe`(青系), `#ffe4e6`(赤系))

## **2\. 接続定義 (edges)**

ノード間の接続線です。各図形の4面（上下左右）には、それぞれ3つずつの接続点（ポート）が存在します。

* `source`: 接続元のノードID  
* `target`: 接続先のノードID  
* `sourcePort`, `targetPort`: 接続位置  
  * 以下の12種類から選択可能です。線が重ならないように使い分けてください。  
  * **上辺**: `top` (中央), `top-L` (左寄り), `top-R` (右寄り)  
  * **下辺**: `bottom` (中央), `bottom-L` (左寄り), `bottom-R` (右寄り)  
  * **左辺**: `left` (中央), `left-L` (上寄り), `left-R` (下寄り)  
  * **右辺**: `right` (中央), `right-L` (上寄り), `right-R` (下寄り)  
  * ※ `-L` や `-R` は、その辺に向かって立ったときの左右を指します（例: `top-L` は上辺の左側）。  
* `label`: 線の上に表示する文字（条件分岐の「Yes/No」など）

# **出力JSONスキーマ**

{  
  "nodes": \[  
    {  
      "id": "node\_start",  
      "type": "circle",  
      "x": 100,  
      "y": 100,  
      "w": 60,  
      "h": 60,  
      "label": "開始",  
      "bgColor": "\#ffffff"  
    }  
    // ...他のノード  
  \],  
  "edges": \[  
    {  
      "id": "edge\_1",  
      "source": "node\_start",  
      "sourcePort": "right",   
      "target": "node\_process\_1",  
      "targetPort": "left-L",   
      "label": ""  
    },  
    {  
      "id": "edge\_2",  
      "source": "node\_start",  
      "sourcePort": "right",   
      "target": "node\_process\_2",  
      "targetPort": "left-R",   
      "label": ""  
    }  
    // ...他のエッジ  
  \]  
}
            </textarea>
            <div class="flex justify-end gap-2" style="justify-content: flex-end;">
                <button id="btn-copy-prompt" class="btn-text btn-primary">コピー</button>
                <button id="btn-close-modal" class="btn-text btn-secondary">閉じる</button>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept=".json" style="display: none;">

    <script>
        /** BizFlow Designer - Offline Logic v7.4 Improved */
        const GRID_SIZE = 10;
        const STORAGE_KEY = 'bizflow_offline_data_v7';
        const MIN_SIZE = 24;

        // Global State
        const state = {
            nodes: [], edges: [], zoom: 1, pan: { x: 0, y: 0 },
            selection: [], clipboard: null, history: [], historyIndex: -1,
            isDragging: false, dragTarget: null, dragStart: { x: 0, y: 0, rawX: 0, rawY: 0 },
            dragItemOffset: {}, tempLine: null, rubberbandRect: null,
            quickAdd: { visible: false, sourceNodeId: null, portDir: null, x: 0, y: 0 },
            activeTab: 'prop', layerDragIdx: null,
            draggingHandle: { edgeId: null, index: -1 }
        };

        // DOM Elements
        const svgEl = document.getElementById('main-svg');
        const viewportEl = document.getElementById('viewport-group');
        const layerSwimlanes = document.getElementById('layer-swimlanes');
        const layerNodes = document.getElementById('layer-nodes');
        const layerEdges = document.getElementById('layer-edges');
        const layerLabels = document.getElementById('layer-labels');
        const layerUI = document.getElementById('layer-ui');
        const wrapperEl = document.getElementById('canvas-wrapper');
        const quickAddMenu = document.getElementById('quick-add-menu');
        const exportMenu = document.getElementById('export-menu');
        const layerListEl = document.getElementById('layer-list');

        // --- UTILS ---
        const uuid = () => 'id-' + Math.random().toString(36).substr(2, 9);
        const snap = (val) => Math.round(val / GRID_SIZE) * GRID_SIZE;

        function getMousePos(evt) {
            let cx, cy;
            if (evt.touches && evt.touches.length > 0) {
                cx = evt.touches[0].clientX; cy = evt.touches[0].clientY;
            } else if (evt.clientX !== undefined) {
                cx = evt.clientX; cy = evt.clientY;
            } else {
                return { x: 0, y: 0 };
            }

            const CTM = svgEl.getScreenCTM();
            if (!CTM) return { x: 0, y: 0 };
            return {
                x: (cx - CTM.e - state.pan.x) / state.zoom,
                y: (cy - CTM.f - state.pan.y) / state.zoom
            };
        }

        function createMultilineText(text, x, y, isSwimlane, size, color, isTextNode) {
            const t = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            const lines = text.split('\n');
            const fontSize = size || 14;
            const lineHeight = fontSize * 1.2;
            t.style.fontSize = fontSize + 'px';
            if (color) t.style.fill = color;

            let startY = y;
            if (!isSwimlane && !isTextNode) startY = y - ((lines.length - 1) * lineHeight) / 2 + (fontSize * 0.35);
            if (isTextNode) startY = y - ((lines.length - 1) * lineHeight) / 2 + (fontSize * 0.35);

            lines.forEach((line, i) => {
                const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                tspan.textContent = line;
                tspan.setAttribute('x', x);
                tspan.setAttribute('dy', i === 0 ? 0 : lineHeight);
                if (i === 0) tspan.setAttribute('y', startY);
                t.appendChild(tspan);
            });
            return t;
        }

        function parsePathPoints(d) {
            const parts = d.split(' ');
            const points = [];
            for (let i = 0; i < parts.length; i += 3) {
                if (parts[i] === 'M' || parts[i] === 'L') points.push({ x: parseFloat(parts[i + 1]), y: parseFloat(parts[i + 2]) });
            }
            return points;
        }

        function getEdgeLabelPosition(d) {
            const points = parsePathPoints(d);
            if (points.length < 2) return { x: 0, y: 0, orientation: 'horizontal' };
            let p1, p2;
            if (points.length === 2) { p1 = points[0]; p2 = points[1]; }
            else if (points.length >= 4) {
                const mid = Math.floor(points.length / 2);
                if (mid > 0) { p1 = points[mid - 1]; p2 = points[mid]; } else { p1 = points[0]; p2 = points[1]; }
            } else { p1 = points[0]; p2 = points[points.length - 1]; }

            const mx = (p1.x + p2.x) / 2;
            const my = (p1.y + p2.y) / 2;
            const orientation = Math.abs(p1.x - p2.x) > Math.abs(p1.y - p2.y) ? 'horizontal' : 'vertical';
            return { x: mx, y: my, orientation };
        }

        function getPortPos(node, dirStr) {
            if (!dirStr) return { x: node.x + node.w / 2, y: node.y + node.h / 2 };

            const parts = dirStr.split('-');
            const mainDir = parts[0];
            const subDir = parts[1];

            let x = node.x, y = node.y;
            let offsetRatio = 0.5;

            if (subDir === 'L') offsetRatio = 0.25;
            if (subDir === 'R') offsetRatio = 0.75;

            if (mainDir === 'top') {
                x += node.w * offsetRatio;
                y = node.y;
            } else if (mainDir === 'bottom') {
                x += node.w * offsetRatio;
                y = node.y + node.h;
            } else if (mainDir === 'left') {
                x = node.x;
                y += node.h * offsetRatio;
            } else if (mainDir === 'right') {
                x = node.x + node.w;
                y += node.h * offsetRatio;
            } else {
                x += node.w / 2;
                y += node.h / 2;
            }

            return { x, y };
        }

        function getDirFromPortStr(dirStr) {
            return dirStr ? dirStr.split('-')[0] : 'top';
        }

        function getManhattanPath(source, sourcePortStr, target, targetPortStr, waypoints) {
            const start = getPortPos(source, sourcePortStr);
            const end = getPortPos(target, targetPortStr);
            const sDir = getDirFromPortStr(sourcePortStr);
            const tDir = getDirFromPortStr(targetPortStr);

            if (!waypoints || waypoints.length === 0) {
                return calculateOrthogonalPath(start, sDir, end, tDir);
            }

            let path = `M ${start.x} ${start.y}`;
            let curr = start;
            let currDir = sDir;

            waypoints.forEach((wp, idx) => {
                const segmentPath = calculateOrthogonalPathPointToPoint(curr, currDir, wp, null);
                path += ' ' + segmentPath.replace(/^M [\d\.]+ [\d\.]+ /, '');
                curr = wp;
                currDir = null;
            });

            const finalSegment = calculateOrthogonalPathPointToPoint(curr, currDir, end, tDir);
            path += ' ' + finalSegment.replace(/^M [\d\.]+ [\d\.]+ /, '');

            return path;
        }

        function calculateOrthogonalPathPointToPoint(p1, dir1, p2, dir2) {
            const d1 = dir1 || (Math.abs(p1.x - p2.x) > Math.abs(p1.y - p2.y) ? (p2.x > p1.x ? 'right' : 'left') : (p2.y > p1.y ? 'bottom' : 'top'));
            const d2 = dir2 || (d1 === 'left' ? 'right' : d1 === 'right' ? 'left' : d1 === 'top' ? 'bottom' : 'top');
            return generatePathString(p1, d1, p2, d2);
        }

        // --- Improved Routing Logic (v7.1) ---
        function generatePathString(s, sourceDir, t, targetDir) {
            let stub = 10;

            let sx = s.x, sy = s.y;
            let tx = t.x, ty = t.y;

            // 特殊ケース：非常に近い距離での直接接続（Stub無視）
            const dist = Math.sqrt(Math.pow(tx - sx, 2) + Math.pow(ty - sy, 2));
            const isAlignedX = Math.abs(tx - sx) < 1;
            const isAlignedY = Math.abs(ty - sy) < 1;

            if ((isAlignedX && (sourceDir === 'top' || sourceDir === 'bottom') && (targetDir === 'top' || targetDir === 'bottom')) ||
                (isAlignedY && (sourceDir === 'left' || sourceDir === 'right') && (targetDir === 'left' || targetDir === 'right'))) {
                return `M ${s.x} ${s.y} L ${t.x} ${t.y}`;
            }

            // Advance start
            if (sourceDir === 'top') sy -= stub;
            else if (sourceDir === 'bottom') sy += stub;
            else if (sourceDir === 'left') sx -= stub;
            else if (sourceDir === 'right') sx += stub;

            // Advance target
            if (targetDir === 'top') ty -= stub;
            else if (targetDir === 'bottom') ty += stub;
            else if (targetDir === 'left') tx -= stub;
            else if (targetDir === 'right') tx += stub;

            let path = `M ${s.x} ${s.y} L ${sx} ${sy}`;

            const dx = tx - sx;
            const dy = ty - sy;

            const isVertS = (sourceDir === 'top' || sourceDir === 'bottom');
            const isVertT = (targetDir === 'top' || targetDir === 'bottom');

            if (isVertS && isVertT) {
                if ((sourceDir === 'bottom' && ty > sy) || (sourceDir === 'top' && ty < sy)) {
                    // Z-shape
                    const midY = sy + dy / 2;
                    path += ` L ${sx} ${midY} L ${tx} ${midY} L ${tx} ${ty}`;
                } else {
                    // U-shape
                    if (Math.abs(sx - tx) < stub * 2) {
                        const detourX = Math.max(sx, tx) + stub;
                        path += ` L ${detourX} ${sy} L ${detourX} ${ty} L ${tx} ${ty}`;
                    } else {
                        const midY = sy + dy / 2;
                        path += ` L ${sx} ${midY} L ${tx} ${midY} L ${tx} ${ty}`;
                    }
                }
            } else if (!isVertS && !isVertT) {
                if ((sourceDir === 'right' && tx > sx) || (sourceDir === 'left' && tx < sx)) {
                    const midX = sx + dx / 2;
                    path += ` L ${midX} ${sy} L ${midX} ${ty} L ${tx} ${ty}`;
                } else {
                    const midYDetour = (sy + ty) / 2;
                    path += ` L ${sx} ${midYDetour} L ${tx} ${midYDetour} L ${tx} ${ty}`;
                }
            } else {
                // L-shape mixed
                const cornerX = (isVertS) ? sx : tx;
                const cornerY = (isVertS) ? ty : sy;
                let bad = false;

                if (sourceDir === 'top' && cornerY > sy) bad = true;
                if (sourceDir === 'bottom' && cornerY < sy) bad = true;
                if (sourceDir === 'left' && cornerX > sx) bad = true;
                if (sourceDir === 'right' && cornerX < sx) bad = true;

                if (targetDir === 'top' && cornerY > ty) bad = true;
                if (targetDir === 'bottom' && cornerY < ty) bad = true;
                if (targetDir === 'left' && cornerX < tx) bad = true;
                if (targetDir === 'right' && cornerX > tx) bad = true;

                if (!bad) {
                    path += ` L ${cornerX} ${cornerY} L ${tx} ${ty}`;
                } else {
                    if (isVertS) path += ` L ${sx} ${ty} L ${tx} ${ty}`;
                    else path += ` L ${tx} ${sy} L ${tx} ${ty}`;
                }
            }

            path += ` L ${t.x} ${t.y}`;
            return path;
        }

        function calculateOrthogonalPath(s, sDir, t, tDir) {
            return generatePathString(s, sDir, t, tDir);
        }

        // --- UI Update ---
        function updateLayerPanel() {
            if (!layerListEl) return;
            layerListEl.innerHTML = '';
            const indexedNodes = state.nodes.map((n, i) => ({ ...n, _idx: i }));
            const reversed = indexedNodes.reverse();
            reversed.forEach((node) => {
                const li = document.createElement('li');
                li.className = 'layer-item';
                li.draggable = true;
                li.dataset.id = node.id;
                let iconChar = '⬜';
                if (node.type === 'circle') iconChar = '⚪'; if (node.type === 'diamond') iconChar = '◇'; if (node.type === 'db') iconChar = '🛢️'; if (node.type === 'swimlane') iconChar = '☰'; if (node.type === 'text') iconChar = 'T';
                if (node.type.startsWith('icon-')) iconChar = '🖼️';

                const label = node.label ? node.label.replace(/\n/g, ' ') : `(No Label)`;
                li.innerHTML = `<div class="layer-item-content"><span class="layer-icon">${iconChar}</span><span class="layer-name">${label}</span></div><span class="layer-handle">☰</span>`;
                li.addEventListener('dragstart', (e) => {
                    state.layerDragIdx = node._idx;
                    li.classList.add('dragging'); e.dataTransfer.effectAllowed = 'move';
                });
                li.addEventListener('dragend', () => { li.classList.remove('dragging'); state.layerDragIdx = null; });
                li.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; });
                li.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const fromIdx = state.layerDragIdx; const toIdx = node._idx;
                    if (fromIdx !== null && fromIdx !== toIdx) {
                        const movedNode = state.nodes[fromIdx];
                        state.nodes.splice(fromIdx, 1);
                        state.nodes.splice(toIdx, 0, movedNode);
                        saveState(); render();
                    }
                });
                li.addEventListener('click', (e) => { handleSelection(e, node.id); });
                if (state.selection.includes(node.id)) { li.style.borderColor = 'var(--primary-color)'; li.style.backgroundColor = '#f0f9ff'; }
                layerListEl.appendChild(li);
            });
        }

        function updatePropsPanel() {
            const empty = document.getElementById('props-empty');
            const multi = document.getElementById('props-multi');
            const content = document.getElementById('props-content');
            const dimGroup = document.getElementById('group-dimensions');
            const styleGroup = document.getElementById('group-style');
            const edgeGroup = document.getElementById('group-edge-style');
            const nodeTypeGroup = document.getElementById('group-node-type');

            if (state.selection.length === 0) {
                empty.style.display = 'block'; multi.style.display = 'none'; content.style.display = 'none';
            } else if (state.selection.length > 1) {
                empty.style.display = 'none'; multi.style.display = 'block'; content.style.display = 'none';
            } else {
                empty.style.display = 'none'; multi.style.display = 'none'; content.style.display = 'block';
                const id = state.selection[0];
                const node = state.nodes.find(n => n.id === id);
                const edge = state.edges.find(e => e.id === id);
                const el = node || edge;
                if (el) {
                    document.getElementById('prop-id').value = el.id;
                    document.getElementById('prop-label').value = el.label || '';
                    document.getElementById('prop-font-size').value = el.fontSize || 14;
                    document.getElementById('prop-text-color').value = el.textColor || '#000000';
                    document.getElementById('prop-text-bg-color').value = (el.textBgColor && el.textBgColor !== 'transparent') ? el.textBgColor : '#ffffff';
                    if (node) {
                        nodeTypeGroup.style.display = 'block'; edgeGroup.style.display = 'none';
                        dimGroup.style.display = 'block'; styleGroup.style.display = 'block';
                        document.getElementById('prop-type').value = node.type;
                        document.getElementById('prop-w').value = node.w;
                        document.getElementById('prop-h').value = node.h;
                        document.getElementById('prop-color').value = node.bgColor || '#ffffff';
                        document.getElementById('prop-stroke-width').value = node.strokeWidth !== undefined ? node.strokeWidth : 2;
                    } else if (edge) {
                        nodeTypeGroup.style.display = 'none'; dimGroup.style.display = 'none';
                        styleGroup.style.display = 'none'; edgeGroup.style.display = 'block';
                        document.getElementById('prop-edge-marker').value = edge.marker || 'end';
                    }
                }
            }
        }

        // --- RENDER ---
        function render() {
            layerSwimlanes.innerHTML = ''; layerNodes.innerHTML = ''; layerEdges.innerHTML = ''; layerLabels.innerHTML = '';
            const tempChildren = Array.from(layerUI.children);
            tempChildren.forEach(c => {
                if (c !== state.tempLine && c !== state.rubberbandRect) layerUI.removeChild(c);
            });
            viewportEl.setAttribute('transform', `translate(${state.pan.x}, ${state.pan.y}) scale(${state.zoom})`);

            state.edges.forEach(edge => {
                const sourceNode = state.nodes.find(n => n.id === edge.source);
                const targetNode = state.nodes.find(n => n.id === edge.target);
                if (!sourceNode || !targetNode) return;

                const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                group.dataset.id = edge.id; group.style.cursor = 'pointer';
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const isSelected = state.selection.includes(edge.id);
                path.setAttribute('class', `connector-path ${isSelected ? 'selected' : ''}`);

                const d = getManhattanPath(sourceNode, edge.sourcePort, targetNode, edge.targetPort, edge.waypoints);
                path.setAttribute('d', d);

                const markerType = edge.marker || 'end';
                if (markerType === 'end' || markerType === 'both') path.setAttribute('marker-end', 'url(#arrow-end)');
                if (markerType === 'start' || markerType === 'both') path.setAttribute('marker-start', 'url(#arrow-start)');

                group.appendChild(path);
                group.addEventListener('mousedown', (e) => { handleSelection(e, edge.id); e.stopPropagation(); });
                layerEdges.appendChild(group);

                if (isSelected) {
                    if (edge.waypoints) {
                        edge.waypoints.forEach((wp, idx) => {
                            const h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            h.setAttribute('class', 'edge-handle');
                            h.setAttribute('cx', wp.x); h.setAttribute('cy', wp.y);
                            h.style.display = 'block';

                            h.addEventListener('mousedown', (e) => {
                                e.stopPropagation();
                                state.isDragging = true;
                                state.dragTarget = 'edge-handle';
                                state.draggingHandle = { edgeId: edge.id, index: idx };
                                state.dragStart = getMousePos(e);
                            });
                            h.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                edge.waypoints.splice(idx, 1);
                                saveState(); render();
                            });
                            layerUI.appendChild(h);
                        });
                    }

                    const points = parsePathPoints(d);
                    for (let i = 0; i < points.length - 1; i++) {
                        const p1 = points[i];
                        const p2 = points[i + 1];
                        if (Math.abs(p1.x - p2.x) > 20 || Math.abs(p1.y - p2.y) > 20) {
                            const midX = (p1.x + p2.x) / 2;
                            const midY = (p1.y + p2.y) / 2;

                            const h = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                            h.setAttribute('class', 'edge-handle');
                            h.setAttribute('cx', midX); h.setAttribute('cy', midY);
                            h.style.display = 'block';
                            h.style.fill = '#cbd5e1';

                            h.addEventListener('mousedown', (e) => {
                                e.stopPropagation();
                                if (!edge.waypoints) edge.waypoints = [];
                                edge.waypoints.push({ x: midX, y: midY });
                                state.isDragging = true;
                                state.dragTarget = 'edge-handle';
                                state.draggingHandle = { edgeId: edge.id, index: edge.waypoints.length - 1 };
                                saveState(); render();
                            });
                            layerUI.appendChild(h);
                        }
                    }
                }

                if (edge.label) {
                    const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    const center = getEdgeLabelPosition(d);
                    const bgColor = (edge.textBgColor && edge.textBgColor !== 'transparent') ? edge.textBgColor : '#ffffff';
                    const lines = edge.label.split('\n'); const fs = edge.fontSize || 14;
                    const maxLineLen = Math.max(...lines.map(l => l.length));
                    const w = Math.max(20, maxLineLen * (fs * 0.7) + 10);
                    const h = lines.length * (fs * 1.2) + 4;
                    const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    bg.setAttribute('class', 'text-bg-rect'); bg.setAttribute('fill', bgColor);
                    bg.setAttribute('x', center.x - w / 2); bg.setAttribute('y', center.y - h / 2);
                    bg.setAttribute('width', w); bg.setAttribute('height', h);
                    labelGroup.style.cursor = 'pointer';
                    labelGroup.addEventListener('mousedown', (e) => { handleSelection(e, edge.id); e.stopPropagation(); });
                    labelGroup.appendChild(bg);
                    const text = createMultilineText(edge.label, center.x, center.y, false, edge.fontSize, edge.textColor, false);
                    text.setAttribute('class', 'edge-label-text'); text.setAttribute('text-anchor', 'middle');
                    text.querySelectorAll('tspan').forEach(ts => ts.setAttribute('x', center.x));
                    labelGroup.appendChild(text);
                    layerLabels.appendChild(labelGroup);
                }
            });

            state.nodes.forEach(node => {
                const isSwimlane = node.type === 'swimlane'; const isText = node.type === 'text';
                const isIcon = node.type.startsWith('icon-');
                const targetLayer = isSwimlane ? layerSwimlanes : layerNodes;
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                const isSelected = state.selection.includes(node.id);
                g.setAttribute('class', `node-group ${isSelected ? 'selected' : ''} ${isText ? 'text-node' : ''}`);
                g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                g.dataset.id = node.id;

                let shape = null;
                // アイコン描画ロジック (塗りつぶし)
                if (isIcon) {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    let iconPath = '';
                    const color = node.bgColor === '#ffffff' ? '#334155' : node.bgColor;

                    if (node.type === 'icon-pc') {
                        iconPath = `<path d="M20 17.575V4H4V17.575H20ZM22 2V19H13V21H16V23H8V21H11V19H2V2H22ZM6 6H18V15.5H6V6Z" fill="${color}"/><rect x="6" y="6" width="12" height="9.5" fill="${color}"/>`;
                    } else if (node.type === 'icon-doc') {
                        iconPath = `<path d="M14 2H6C4.9 2 4 2.9 4 4V20C4 21.1 4.9 22 6 22H18C19.1 22 20 21.1 20 20V8L14 2ZM13 9V3.5L18.5 9H13Z" fill="${color}"/>`;
                    } else if (node.type === 'icon-server') {
                        iconPath = `<path d="M2 20V4H22V20H2ZM4 6V10H20V6H4ZM4 12V18H20V12H4ZM6 7V9H8V7H6ZM6 13V15H8V13H6Z" fill="${color}"/>`;
                    } else if (node.type === 'icon-user') {
                        iconPath = `<path d="M12 12C14.21 12 16 10.21 16 8C16 5.79 14.21 4 12 4C9.79 4 8 5.79 8 8C8 10.21 9.79 12 12 12ZM12 14C9.33 14 4 15.34 4 18V20H20V18C20 15.34 14.67 14 12 14Z" fill="${color}"/>`;
                    }

                    const scaleX = node.w / 24;
                    const scaleY = node.h / 24;
                    shape.innerHTML = iconPath;
                    shape.setAttribute('transform', `scale(${scaleX}, ${scaleY})`);

                    const hit = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    hit.setAttribute('width', 24); hit.setAttribute('height', 24);
                    hit.setAttribute('fill', 'transparent');
                    shape.appendChild(hit);

                } else if (node.type === 'circle') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    shape.setAttribute('cx', node.w / 2); shape.setAttribute('cy', node.h / 2);
                    shape.setAttribute('r', Math.min(node.w, node.h) / 2);
                } else if (node.type === 'diamond') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const w = node.w, h = node.h;
                    shape.setAttribute('points', `${w / 2},0 ${w},${h / 2} ${w / 2},${h} 0,${h / 2}`);
                } else if (node.type === 'db') {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    const w = node.w, h = node.h; const ry = h * 0.15;
                    shape.setAttribute('d', `M 0 ${ry} A ${w / 2} ${ry} 0 1 1 ${w} ${ry} A ${w / 2} ${ry} 0 1 1 0 ${ry} z M 0 ${ry} L 0 ${h - ry} A ${w / 2} ${ry} 0 0 0 ${w} ${h - ry} L ${w} ${ry} A ${w / 2} ${ry} 0 0 1 0 ${ry}`);
                    shape.setAttribute('fill-rule', 'evenodd');
                } else if (isText) {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shape.setAttribute('width', node.w); shape.setAttribute('height', node.h);
                    shape.setAttribute('fill', 'transparent'); shape.setAttribute('stroke', 'none');
                } else {
                    shape = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    shape.setAttribute('width', node.w); shape.setAttribute('height', node.h);
                    shape.setAttribute('rx', node.type === 'rect' ? 6 : 0);
                }

                if (shape) {
                    if (!isText && !isIcon) {
                        shape.setAttribute('class', 'node-body');
                        const sw = node.strokeWidth !== undefined ? node.strokeWidth : 2;
                        shape.setAttribute('stroke-width', sw);
                        if (sw === 0) shape.setAttribute('stroke', 'none');
                        if (isSwimlane) {
                            shape.setAttribute('stroke-dasharray', '5 5');
                            shape.setAttribute('fill', node.bgColor || '#f8fafc');
                            shape.setAttribute('fill-opacity', (!node.bgColor || node.bgColor === '#ffffff') ? '0.5' : '1');
                        } else {
                            shape.setAttribute('fill', node.bgColor || '#ffffff');
                        }
                    }
                    g.appendChild(shape);
                }

                let textX = node.w / 2; let textY = isSwimlane ? 20 : node.h / 2; let anchor = 'middle';
                if (isIcon) { textY = node.h + 10; }
                if (isText) { textX = 0; textY = node.h / 2; anchor = 'start'; }

                if (node.label) {
                    if (node.textBgColor && node.textBgColor !== 'transparent' && !isIcon) {
                        const lines = node.label.split('\n'); const fs = node.fontSize || 14;
                        const maxLineLen = Math.max(...lines.map(l => l.length));
                        const tw = Math.max(20, maxLineLen * (fs * 0.7) + 10);
                        const th = lines.length * (fs * 1.3) + 4;
                        const bg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bg.setAttribute('class', 'text-bg-rect'); bg.setAttribute('fill', node.textBgColor);
                        let bgX = textX - tw / 2; let bgY = textY - th / 2;
                        if (anchor === 'start') bgX = textX - 2;

                        if (isSwimlane) bgY = textY - fs;
                        else if (isText) bgY = textY - (lines.length * (fs * 1.2)) / 2;
                        else bgY = textY - (lines.length * (fs * 1.2)) / 2;

                        bg.setAttribute('x', bgX); bg.setAttribute('y', bgY); bg.setAttribute('width', tw); bg.setAttribute('height', th);
                        g.appendChild(bg);
                    }
                    const text = createMultilineText(node.label, textX, textY, isSwimlane, node.fontSize, node.textColor, isText);
                    text.setAttribute('class', 'node-label'); text.setAttribute('text-anchor', anchor);
                    if (isSwimlane) text.style.fontWeight = 'bold';
                    g.appendChild(text);
                }

                if (!isSwimlane && !isText && !isIcon) {
                    const dirs = [
                        'top-L', 'top', 'top-R',
                        'right-L', 'right', 'right-R',
                        'bottom-L', 'bottom', 'bottom-R',
                        'left-L', 'left', 'left-R'
                    ];

                    dirs.forEach(dirStr => {
                        const p = getPortPos(node, dirStr);
                        const relX = p.x - node.x;
                        const relY = p.y - node.y;

                        const port = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        port.setAttribute('class', 'port');
                        port.setAttribute('cx', relX); port.setAttribute('cy', relY);
                        port.addEventListener('mousedown', (e) => { e.stopPropagation(); startConnectionDrag(e, node, { x: relX, y: relY, dir: dirStr }); });
                        if (!dirStr.includes('-')) {
                            port.addEventListener('contextmenu', (e) => { e.preventDefault(); e.stopPropagation(); showQuickAddMenu(e, node, { dir: dirStr }); });
                        }

                        port.dataset.nodeId = node.id; port.dataset.dir = dirStr;
                        g.appendChild(port);
                    });
                }

                if (isSelected && state.selection.length === 1 && !isText) {
                    const handle = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    handle.setAttribute('class', 'resize-handle'); handle.setAttribute('x', node.w - 5); handle.setAttribute('y', node.h - 5);
                    handle.addEventListener('mousedown', (e) => { e.stopPropagation(); startResizeDrag(e, node); });
                    g.appendChild(handle);
                }
                g.addEventListener('mousedown', (e) => {
                    if (e.target.classList.contains('port') || e.target.classList.contains('resize-handle')) return;
                    handleSelection(e, node.id); startNodeDrag(e); e.stopPropagation();
                });
                g.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    const newLabel = prompt('ラベル編集:', node.label);
                    if (newLabel !== null) { node.label = newLabel.replace(/\\n/g, '\n'); saveState(); render(); updatePropsPanel(); }
                });
                targetLayer.appendChild(g);
            });

            if (state.selection.length === 1) {
                const node = state.nodes.find(n => n.id === state.selection[0]);
                if (node && !node.type.startsWith('icon-') && node.type !== 'swimlane' && node.type !== 'text') {
                    const padding = 20;
                    const handles = [{ dir: 'top', x: node.x + node.w / 2, y: node.y - padding }, { dir: 'bottom', x: node.x + node.w / 2, y: node.y + node.h + padding }, { dir: 'left', x: node.x - padding, y: node.y + node.h / 2 }, { dir: 'right', x: node.x + node.w + padding, y: node.y + node.h / 2 }];
                    handles.forEach(h => {
                        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                        g.setAttribute('class', 'quick-add-group'); g.style.cursor = 'pointer';
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('class', 'quick-add-handle'); circle.setAttribute('cx', h.x); circle.setAttribute('cy', h.y); circle.setAttribute('r', 8);
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('class', 'quick-add-symbol'); path.setAttribute('d', `M ${h.x - 4} ${h.y} L ${h.x + 4} ${h.y} M ${h.x} ${h.y - 4} L ${h.x} ${h.y + 4}`);
                        g.appendChild(circle); g.appendChild(path);
                        g.addEventListener('mousedown', (e) => { e.stopPropagation(); showQuickAddMenu(e, node, { dir: h.dir }, true); });
                        layerUI.appendChild(g);
                    });
                }
            }
            if (state.activeTab === 'layer') updateLayerPanel();
        }

        function handleSelection(e, id) {
            if (e.shiftKey || e.ctrlKey) {
                if (state.selection.includes(id)) state.selection = state.selection.filter(sid => sid !== id);
                else state.selection.push(id);
            } else {
                if (state.selection.length > 1 && state.selection.includes(id)) { } else { state.selection = [id]; }
            }
            render(); updatePropsPanel();
        }

        function showQuickAddMenu(e, node, p, fromHandle = false) {
            state.quickAdd = { visible: true, sourceNodeId: node.id, portDir: p.dir, x: e.clientX, y: e.clientY };
            quickAddMenu.style.left = e.clientX + 'px'; quickAddMenu.style.top = e.clientY + 'px'; quickAddMenu.style.display = 'grid';
        }
        function hideQuickAddMenu() { quickAddMenu.style.display = 'none'; state.quickAdd.visible = false; }

        function startNodeDrag(e) {
            state.isDragging = true; state.dragTarget = 'node';
            const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            state.dragStart = { rawX, rawY };
            state.dragItemOffset = {};

            // ノードのオフセット記録
            state.selection.forEach(id => {
                const n = state.nodes.find(node => node.id === id);
                if (n) state.dragItemOffset[id] = { x: n.x, y: n.y };
            });

            // 接続線追従移動の準備 (v7.1)
            const selectedNodeIds = new Set(state.selection);
            state.edges.forEach(edge => {
                if (selectedNodeIds.has(edge.source) && selectedNodeIds.has(edge.target) && edge.waypoints) {
                    state.dragItemOffset[`edge-wp-${edge.id}`] = JSON.parse(JSON.stringify(edge.waypoints));
                }
            });
        }
        function startResizeDrag(e, node) {
            state.isDragging = true; state.dragTarget = 'resize';
            const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            state.dragStart = { rawX, rawY };
            state.dragItemOffset = { w: node.w, h: node.h, id: node.id };
        }
        function startConnectionDrag(e, sourceNode, portConfig) {
            state.isDragging = true; state.dragTarget = 'port';
            state.dragStart = { nodeId: sourceNode.id, portDir: portConfig.dir, x: sourceNode.x + portConfig.x, y: sourceNode.y + portConfig.y };
            state.tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            state.tempLine.setAttribute('stroke', '#3b82f6'); state.tempLine.setAttribute('stroke-width', '2'); state.tempLine.setAttribute('stroke-dasharray', '4 4');
            const sx = state.dragStart.x, sy = state.dragStart.y;
            state.tempLine.setAttribute('x1', sx); state.tempLine.setAttribute('y1', sy); state.tempLine.setAttribute('x2', sx); state.tempLine.setAttribute('y2', sy);
            layerUI.appendChild(state.tempLine);
        }
        function startRubberband(e) {
            state.isDragging = true; state.dragTarget = 'rubberband';
            const pos = getMousePos(e);
            state.dragStart = { x: pos.x, y: pos.y };
            state.rubberbandRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            state.rubberbandRect.setAttribute('class', 'rubberband');
            state.rubberbandRect.setAttribute('x', pos.x); state.rubberbandRect.setAttribute('y', pos.y);
            layerUI.appendChild(state.rubberbandRect);
            if (!e.shiftKey && !e.ctrlKey) state.selection = []; render();
        }
        function startPan(e) {
            state.isDragging = true; state.dragTarget = 'pan';
            const rawX = (e.touches && e.touches.length) ? e.touches[0].clientX : e.clientX;
            const rawY = (e.touches && e.touches.length) ? e.touches[0].clientY : e.clientY;
            state.dragStart = { rawX, rawY };
            state.dragItemOffset = { ...state.pan };
            wrapperEl.style.cursor = 'grabbing';
        }

        function saveState() {
            if (state.historyIndex < state.history.length - 1) state.history = state.history.slice(0, state.historyIndex + 1);
            const s = JSON.stringify({ nodes: state.nodes, edges: state.edges });
            state.history.push(s); state.historyIndex++;
            updateBtns();
            try { localStorage.setItem(STORAGE_KEY, s); } catch (e) { }
            showToast('保存しました');
        }
        function undo() { if (state.historyIndex > 0) { state.historyIndex--; restore(state.history[state.historyIndex]); } }
        function redo() { if (state.historyIndex < state.history.length - 1) { state.historyIndex++; restore(state.history[state.historyIndex]); } }
        function restore(s) { const d = JSON.parse(s); state.nodes = d.nodes; state.edges = d.edges; state.selection = []; render(); updateBtns(); }
        function updateBtns() {
            document.getElementById('btn-undo').disabled = state.historyIndex <= 0;
            document.getElementById('btn-redo').disabled = state.historyIndex >= state.history.length - 1;
        }
        function showToast(msg) {
            const t = document.getElementById('toast'); t.textContent = msg; t.style.opacity = '1';
            setTimeout(() => t.style.opacity = '0', 2000);
        }
        function setZoom(v) { state.zoom = Math.max(0.2, Math.min(3, v)); document.getElementById('zoom-level').textContent = Math.round(state.zoom * 100) + '%'; render(); }
        function updateSelectedProps(key, value, isNumeric = false) {
            let changed = false;
            state.selection.forEach(id => {
                const n = state.nodes.find(node => node.id === id);
                const e = state.edges.find(edge => edge.id === id);
                const target = n || e;
                if (target) { target[key] = isNumeric ? parseFloat(value) : value; changed = true; }
            });
            if (changed) render();
            return changed;
        }

        // --- EVENT LISTENERS ---

        // Toolbar Buttons
        document.getElementById('btn-undo').addEventListener('click', undo);
        document.getElementById('btn-redo').addEventListener('click', redo);
        document.getElementById('btn-home').addEventListener('click', () => { state.pan = { x: 0, y: 0 }; state.zoom = 1; setZoom(1); });
        document.getElementById('btn-clear').addEventListener('click', () => { if (confirm('全てクリアしますか？')) { state.nodes = []; state.edges = []; saveState(); render(); } });
        document.getElementById('btn-zoom-in').addEventListener('click', () => setZoom(state.zoom + 0.1));
        document.getElementById('btn-zoom-out').addEventListener('click', () => setZoom(state.zoom - 0.1));
        document.getElementById('btn-fit').addEventListener('click', () => { state.zoom = 1; state.pan = { x: 0, y: 0 }; setZoom(1); });

        // UPDATE: AI Modal Logic
        const modal = document.getElementById('ai-prompt-modal');
        document.getElementById('btn-ai-prompt').addEventListener('click', () => { modal.style.display = 'flex'; });
        document.getElementById('btn-close-modal').addEventListener('click', () => { modal.style.display = 'none'; });
        document.getElementById('btn-copy-prompt').addEventListener('click', () => {
            const textarea = document.getElementById('ai-prompt-text');
            textarea.select();
            document.execCommand('copy');
            showToast('コピーしました');
        });
        modal.addEventListener('click', (e) => { if (e.target === modal) modal.style.display = 'none'; });

        // UPDATE: Export Menu Positioning Logic (Fix for overflow clipping)
        const btnExportMenu = document.getElementById('btn-export-menu');
        // NOTE: exportMenu is already defined in DOM Elements section

        btnExportMenu.addEventListener('click', (e) => {
            e.stopPropagation();
            const isVisible = exportMenu.style.display === 'flex';

            if (isVisible) {
                exportMenu.style.display = 'none';
            } else {
                // Calculate position relative to viewport because it's fixed
                const rect = btnExportMenu.getBoundingClientRect();
                exportMenu.style.top = (rect.bottom + 4) + 'px';
                // Align right edge of menu with right edge of button
                // width is 180px
                exportMenu.style.left = (rect.right - 180) + 'px';
                exportMenu.style.display = 'flex';
            }
        });

        // Close export menu on interaction outside
        window.addEventListener('click', (e) => {
            if (!e.target.closest('#btn-export-menu') && !e.target.closest('#export-menu')) {
                exportMenu.style.display = 'none';
            }
        });
        // Also close on scroll or resize to prevent floating menu issues
        window.addEventListener('scroll', () => { if (exportMenu.style.display === 'flex') exportMenu.style.display = 'none'; }, true);
        window.addEventListener('resize', () => { if (exportMenu.style.display === 'flex') exportMenu.style.display = 'none'; });


        // Properties
        document.getElementById('prop-label').addEventListener('input', (e) => updateSelectedProps('label', e.target.value));
        document.getElementById('prop-label').addEventListener('change', saveState);
        document.getElementById('prop-type').addEventListener('change', (e) => { updateSelectedProps('type', e.target.value); saveState(); });
        document.getElementById('prop-font-size').addEventListener('input', (e) => { updateSelectedProps('fontSize', e.target.value, true); saveState(); });
        document.getElementById('prop-text-color').addEventListener('input', (e) => { updateSelectedProps('textColor', e.target.value); saveState(); });
        document.getElementById('prop-text-bg-color').addEventListener('input', (e) => { updateSelectedProps('textBgColor', e.target.value); saveState(); });
        document.getElementById('btn-text-bg-none').addEventListener('click', () => { updateSelectedProps('textBgColor', 'transparent'); saveState(); });
        document.getElementById('prop-color').addEventListener('input', (e) => { updateSelectedProps('bgColor', e.target.value); saveState(); });
        document.getElementById('prop-stroke-width').addEventListener('input', (e) => { updateSelectedProps('strokeWidth', e.target.value, true); saveState(); });
        document.getElementById('btn-reset-color').addEventListener('click', () => { updateSelectedProps('bgColor', '#ffffff'); document.getElementById('prop-color').value = '#ffffff'; saveState(); });
        document.getElementById('prop-edge-marker').addEventListener('change', (e) => { updateSelectedProps('marker', e.target.value); saveState(); });
        document.getElementById('prop-w').addEventListener('input', (e) => {
            if (state.selection.length === 1) { const n = state.nodes.find(x => x.id === state.selection[0]); if (n) { n.w = Math.max(MIN_SIZE, snap(parseInt(e.target.value))); render(); saveState(); } }
        });
        document.getElementById('prop-h').addEventListener('input', (e) => {
            if (state.selection.length === 1) { const n = state.nodes.find(x => x.id === state.selection[0]); if (n) { n.h = Math.max(MIN_SIZE, snap(parseInt(e.target.value))); render(); saveState(); } }
        });

        // Color Palette
        document.querySelectorAll('.color-swatch').forEach(swatch => {
            swatch.addEventListener('click', () => {
                const color = swatch.dataset.color;
                updateSelectedProps('bgColor', color);
                document.getElementById('prop-color').value = color;
                saveState();
            });
        });

        // Global
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                document.querySelectorAll('.panel-content').forEach(p => p.classList.remove('active'));
                btn.classList.add('active');
                const tabId = `tab-${btn.dataset.tab}`;
                document.getElementById(tabId).classList.add('active');
                state.activeTab = btn.dataset.tab;
                if (state.activeTab === 'layer') updateLayerPanel();
            });
        });

        document.querySelectorAll('.quick-add-item').forEach(item => {
            item.addEventListener('click', (e) => {
                if (!state.quickAdd.visible) return;
                const type = item.dataset.type;
                const sourceNode = state.nodes.find(n => n.id === state.quickAdd.sourceNodeId);
                if (!sourceNode) return;
                let w = 120, h = 60, lbl = '処理';
                if (type === 'circle') { w = 60; h = 60; lbl = '終了'; }
                if (type === 'diamond') { w = 80; h = 80; lbl = '?'; }
                if (type === 'db') { w = 60; h = 60; lbl = 'DB'; }
                const offset = 80;
                let nx = sourceNode.x, ny = sourceNode.y;
                const dir = state.quickAdd.portDir ? state.quickAdd.portDir.split('-')[0] : 'bottom';

                if (dir === 'top') { nx += (sourceNode.w - w) / 2; ny -= (h + offset); }
                if (dir === 'bottom') { nx += (sourceNode.w - w) / 2; ny += (sourceNode.h + offset); }
                if (dir === 'left') { nx -= (w + offset); ny += (sourceNode.h - h) / 2; }
                if (dir === 'right') { nx += (sourceNode.w + offset); ny += (sourceNode.h - h) / 2; }
                const newNode = { id: uuid(), type: type, x: snap(nx), y: snap(ny), w: w, h: h, label: lbl, bgColor: '#ffffff', strokeWidth: 2 };

                let targetDir = 'top';
                if (dir === 'top') targetDir = 'bottom'; if (dir === 'bottom') targetDir = 'top'; if (dir === 'left') targetDir = 'right'; if (dir === 'right') targetDir = 'left';

                state.nodes.push(newNode);
                state.edges.push({ id: uuid(), source: sourceNode.id, sourcePort: state.quickAdd.portDir, target: newNode.id, targetPort: targetDir, label: '' });
                state.selection = [newNode.id];
                saveState(); render(); hideQuickAddMenu();
            });
        });

        // MOUSE EVENTS
        window.addEventListener('mousemove', (e) => {
            if (!state.isDragging) return;
            const CTM = svgEl.getScreenCTM();
            const mouseX = (e.clientX - CTM.e - state.pan.x) / state.zoom;
            const mouseY = (e.clientY - CTM.f - state.pan.y) / state.zoom;

            if (state.dragTarget === 'node') {
                const deltaX = (e.clientX - state.dragStart.rawX) / state.zoom;
                const deltaY = (e.clientY - state.dragStart.rawY) / state.zoom;

                // ノード移動
                state.selection.forEach(id => {
                    const node = state.nodes.find(n => n.id === id);
                    if (node && state.dragItemOffset[id]) {
                        node.x = snap(state.dragItemOffset[id].x + deltaX);
                        node.y = snap(state.dragItemOffset[id].y + deltaY);
                    }
                });

                // 追従するWaypoints移動
                Object.keys(state.dragItemOffset).forEach(key => {
                    if (key.startsWith('edge-wp-')) {
                        const edgeId = key.replace('edge-wp-', '');
                        const edge = state.edges.find(e => e.id === edgeId);
                        const initialWPs = state.dragItemOffset[key];
                        if (edge && initialWPs) {
                            edge.waypoints = initialWPs.map(wp => ({
                                x: snap(wp.x + deltaX),
                                y: snap(wp.y + deltaY)
                            }));
                        }
                    }
                });

                requestAnimationFrame(render);
            } else if (state.dragTarget === 'resize') {
                const node = state.nodes.find(n => n.id === state.dragItemOffset.id);
                if (node) {
                    const deltaX = (e.clientX - state.dragStart.rawX) / state.zoom;
                    const deltaY = (e.clientY - state.dragStart.rawY) / state.zoom;
                    node.w = Math.max(MIN_SIZE, snap(state.dragItemOffset.w + deltaX));
                    node.h = Math.max(MIN_SIZE, snap(state.dragItemOffset.h + deltaY));
                    requestAnimationFrame(render);
                }
            } else if (state.dragTarget === 'port') {
                state.tempLine.setAttribute('x2', mouseX); state.tempLine.setAttribute('y2', mouseY);
            } else if (state.dragTarget === 'edge-handle') {
                const edge = state.edges.find(e => e.id === state.draggingHandle.edgeId);
                if (edge && edge.waypoints) {
                    const wp = edge.waypoints[state.draggingHandle.index];
                    if (wp) {
                        wp.x = snap(mouseX);
                        wp.y = snap(mouseY);
                        requestAnimationFrame(render);
                    }
                }
            } else if (state.dragTarget === 'pan') {
                const dx = e.clientX - state.dragStart.x;
                const dy = e.clientY - state.dragStart.y;
                state.pan.x = state.dragItemOffset.x + dx; state.pan.y = state.dragItemOffset.y + dy;
                requestAnimationFrame(render);
            } else if (state.dragTarget === 'rubberband') {
                const x = Math.min(state.dragStart.x, mouseX);
                const y = Math.min(state.dragStart.y, mouseY);
                const w = Math.abs(mouseX - state.dragStart.x);
                const h = Math.abs(mouseY - state.dragStart.y);
                state.rubberbandRect.setAttribute('x', x); state.rubberbandRect.setAttribute('y', y);
                state.rubberbandRect.setAttribute('width', w); state.rubberbandRect.setAttribute('height', h);
            }
        });

        svgEl.addEventListener('mousedown', (e) => {
            if (state.quickAdd.visible) hideQuickAddMenu();
            // exportMenu logic moved to window click listener
            if (e.button === 0) {
                if (e.code === 'Space' || e.button === 1) startPan(e);
                else if (e.target.id === 'main-svg' || e.target.id === 'bg-rect') startRubberband(e);
            }
        });

        // SCROLL / ZOOM
        wrapperEl.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.ctrlKey) {
                const delta = e.deltaY > 0 ? -0.05 : 0.05;
                setZoom(state.zoom + delta);
            } else {
                let dx = -e.deltaX; let dy = -e.deltaY;
                if (dx === 0 && e.shiftKey) { dx = -e.deltaY; dy = 0; }
                state.pan.x += dx; state.pan.y += dy; render();
            }
        }, { passive: false });

        // TOUCH EVENTS (Zoom/Pan)
        let touchStartDist = 0;
        let touchStartZoom = 1;
        let touchStartPan = { x: 0, y: 0 };

        wrapperEl.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                if (e.target.id === 'main-svg' || e.target.id === 'bg-rect') {
                    startPan(e.touches[0]);
                }
            } else if (e.touches.length === 2) {
                state.isDragging = true;
                state.dragTarget = 'pinch';
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDist = Math.sqrt(dx * dx + dy * dy);
                touchStartZoom = state.zoom;
            }
        }, { passive: false });

        wrapperEl.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1 && state.dragTarget === 'pan') {
                e.preventDefault();
                const touch = e.touches[0];
                const dx = touch.clientX - state.dragStart.x;
                const dy = touch.clientY - state.dragStart.y;
                state.pan.x = state.dragItemOffset.x + dx;
                state.pan.y = state.dragItemOffset.y + dy;
                render();
            } else if (e.touches.length === 2 && state.dragTarget === 'pinch') {
                e.preventDefault();
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (touchStartDist > 0) {
                    const scale = dist / touchStartDist;
                    setZoom(touchStartZoom * scale);
                }
            }
        }, { passive: false });

        window.addEventListener('touchend', (e) => {
            if (state.dragTarget === 'pinch' || state.dragTarget === 'pan') {
                state.isDragging = false;
                state.dragTarget = null;
                wrapperEl.style.cursor = 'default';
            }
        });

        // KEYBOARD
        window.addEventListener('keydown', (e) => {
            const activeTag = document.activeElement ? document.activeElement.tagName.toUpperCase() : '';
            const isInput = (activeTag === 'INPUT' || activeTag === 'TEXTAREA');
            if (e.code === 'Space' && !isInput) wrapperEl.style.cursor = 'grab';
            if ((e.ctrlKey || e.metaKey) && e.key === 'a' && !isInput) {
                e.preventDefault();
                state.selection = [...state.nodes.map(n => n.id), ...state.edges.map(e => e.id)];
                render(); updatePropsPanel();
            }
            if ((e.key === 'Delete' || e.key === 'Backspace') && !isInput && state.selection.length > 0) {
                if (confirm('選択項目を削除しますか？')) {
                    state.nodes = state.nodes.filter(n => !state.selection.includes(n.id));
                    // 修正: エッジ自身のIDが含まれている場合も削除対象とする
                    state.edges = state.edges.filter(edge =>
                        !state.selection.includes(edge.id) &&
                        !state.selection.includes(edge.source) &&
                        !state.selection.includes(edge.target)
                    );
                    state.selection = []; saveState(); render(); updatePropsPanel();
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'c' && !isInput) {
                if (state.selection.length > 0) {
                    const n = state.nodes.filter(n => state.selection.includes(n.id));
                    const e = state.edges.filter(e => state.selection.includes(e.source) && state.selection.includes(e.target));
                    state.clipboard = JSON.parse(JSON.stringify({ nodes: n, edges: e }));
                    showToast('コピーしました');
                }
            }
            if ((e.ctrlKey || e.metaKey) && e.key === 'v' && !isInput) {
                if (state.clipboard) {
                    const idMap = {}; const off = 20; const nn = []; const ne = []; const ns = [];
                    state.clipboard.nodes.forEach(n => {
                        const nid = uuid(); idMap[n.id] = nid;
                        nn.push({ ...n, id: nid, x: n.x + off, y: n.y + off }); ns.push(nid);
                    });
                    state.clipboard.edges.forEach(e => {
                        if (idMap[e.source] && idMap[e.target]) ne.push({ ...e, id: uuid(), source: idMap[e.source], target: idMap[e.target] });
                    });
                    state.nodes.push(...nn); state.edges.push(...ne); state.selection = ns; saveState(); render(); showToast('貼り付けました');
                }
            }
            // UPDATE: Fix Undo/Redo hijack
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !isInput) { e.preventDefault(); undo(); }
            if ((e.ctrlKey || e.metaKey) && e.key === 'y' && !isInput) { e.preventDefault(); redo(); }
        });
        window.addEventListener('keyup', (e) => { if (e.code === 'Space') wrapperEl.style.cursor = 'default'; });

        window.addEventListener('mouseup', (e) => {
            if (!state.isDragging) return;
            if (state.dragTarget === 'port') {
                state.tempLine.remove();
                const el = document.elementFromPoint(e.clientX, e.clientY);
                if (el && el.classList.contains('port')) {
                    const tId = el.dataset.nodeId; const tDir = el.dataset.dir;
                    if (tId && tId !== state.dragStart.nodeId) {
                        state.edges.push({ id: uuid(), source: state.dragStart.nodeId, sourcePort: state.dragStart.portDir, target: tId, targetPort: tDir, label: '', marker: 'end' });
                        saveState();
                    }
                }
            } else if (state.dragTarget === 'rubberband') {
                const r = state.rubberbandRect;
                const rx = parseFloat(r.getAttribute('x')); const ry = parseFloat(r.getAttribute('y'));
                const rw = parseFloat(r.getAttribute('width')); const rh = parseFloat(r.getAttribute('height'));
                state.nodes.forEach(n => {
                    if (n.x < rx + rw && n.x + n.w > rx && n.y < ry + rh && n.y + n.h > ry) { if (!state.selection.includes(n.id)) state.selection.push(n.id); }
                });
                state.rubberbandRect.remove(); updatePropsPanel();
            } else if (['node', 'resize', 'edge-handle'].includes(state.dragTarget)) { saveState(); }
            if (state.dragTarget === 'pan') wrapperEl.style.cursor = 'default';
            state.isDragging = false; state.dragTarget = null; render();
        });

        // DND
        const dndItems = document.querySelectorAll('.dnd-item');
        dndItems.forEach(item => item.addEventListener('dragstart', (e) => e.dataTransfer.setData('type', item.dataset.type)));
        wrapperEl.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
        wrapperEl.addEventListener('drop', (e) => {
            e.preventDefault(); const type = e.dataTransfer.getData('type'); if (!type) return;
            const pos = getMousePos(e);
            let w = 120, h = 60, lbl = '処理', bg = '#ffffff';
            let strokeW = 2; // Default stroke width
            if (type === 'circle') { w = 60; h = 60; lbl = '開始'; }
            else if (type === 'diamond') { w = 80; h = 80; lbl = '?'; }
            else if (type === 'db') { w = 60; h = 60; lbl = 'DB'; }
            else if (type === 'swimlane') {
                w = 300; h = 400; lbl = '担当領域'; bg = '#f8fafc';
                strokeW = 0.5; // UPDATE: スイムレーンのデフォルト線幅を0.5に変更
            }
            else if (type === 'text') { w = 120; h = 40; lbl = 'テキスト'; bg = 'transparent'; }
            else if (type.startsWith('icon-')) { w = 48; h = 48; lbl = ''; bg = '#334155'; }

            if (type === 'icon-pc') lbl = '端末';
            if (type === 'icon-doc') lbl = '資料';
            if (type === 'icon-server') lbl = 'サーバー';
            if (type === 'icon-user') lbl = 'ユーザー';

            const newNode = { id: uuid(), type: type, x: snap(pos.x - w / 2), y: snap(pos.y - h / 2), w: w, h: h, label: lbl, bgColor: bg, strokeWidth: strokeW };
            state.nodes.push(newNode); saveState(); state.selection = [newNode.id]; render();
        });

        // Export & Init
        // Note: Event Listeners for Export Buttons are defined in the specific block above

        document.getElementById('export-json').addEventListener('click', () => {
            const b = new Blob([JSON.stringify({ nodes: state.nodes, edges: state.edges }, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `bizflow_${Date.now()}.json`; a.click();
        });

        document.getElementById('export-pdf').addEventListener('click', () => {
            if (state.nodes.length === 0) return alert('キャンバスが空です');
            const originalZoom = state.zoom; const originalPan = { ...state.pan };
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(n => { if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y; if (n.x + n.w > maxX) maxX = n.x + n.w; if (n.y + n.h > maxY) maxY = n.y + n.h; });
            const padding = 20; state.pan.x = -minX + padding; state.pan.y = -minY + padding; state.zoom = 1;
            render(); setTimeout(() => { window.print(); state.pan = originalPan; state.zoom = originalZoom; render(); }, 100);
        });

        function exportImage(format) {
            exportMenu.style.display = 'none';
            if (state.nodes.length === 0) return alert('キャンバスが空です');
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            state.nodes.forEach(n => { if (n.x < minX) minX = n.x; if (n.y < minY) minY = n.y; if (n.x + n.w > maxX) maxX = n.x + n.w; if (n.y + n.h > maxY) maxY = n.y + n.h; });
            const padding = 50; const width = maxX - minX + padding * 2; const height = maxY - minY + padding * 2;
            const clone = svgEl.cloneNode(true);
            const viewport = clone.getElementById('viewport-group');
            viewport.setAttribute('transform', `translate(${padding - minX}, ${padding - minY})`);
            clone.setAttribute('width', width); clone.setAttribute('height', height);
            clone.querySelectorAll('.port, .resize-handle, .edge-handle, #layer-ui').forEach(el => el.remove());
            const isPng = format === 'image/png';
            const bgColor = isPng ? 'transparent' : '#f0f0f0';
            clone.style.background = bgColor;
            const style = document.createElement('style');
            style.textContent = `.node-body { stroke: #1e293b; vector-effect: non-scaling-stroke; } .connector-path { fill: none; stroke: #64748b; stroke-width: 2px; stroke-linejoin: round; stroke-linecap: round; } .node-label, .edge-label-text { font-family: sans-serif; font-size: 14px; fill: #334155; } .text-bg-rect { fill-opacity: 1; stroke: none; }`;
            clone.insertBefore(style, clone.firstChild);
            const svgData = new XMLSerializer().serializeToString(clone);

            if (format === 'image/svg+xml') {
                const b = new Blob([svgData], { type: 'image/svg+xml' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(b); a.download = `bizflow_${Date.now()}.svg`; a.click();
                return;
            }

            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas'); canvas.width = width; canvas.height = height; const ctx = canvas.getContext('2d');
                if (!isPng) { ctx.fillStyle = '#f0f0f0'; ctx.fillRect(0, 0, width, height); ctx.strokeStyle = '#e2e8f0'; ctx.lineWidth = 1; ctx.beginPath(); for (let x = 0; x <= width; x += 20) { ctx.moveTo(x, 0); ctx.lineTo(x, height); } for (let y = 0; y <= height; y += 20) { ctx.moveTo(0, y); ctx.lineTo(width, y); } ctx.stroke(); }
                ctx.drawImage(img, 0, 0);
                const a = document.createElement('a'); a.href = canvas.toDataURL(format); a.download = `bizflow_${Date.now()}.${isPng ? 'png' : 'jpg'}`; a.click();
            };
            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }
        document.getElementById('export-png').addEventListener('click', () => exportImage('image/png'));
        document.getElementById('export-jpeg').addEventListener('click', () => exportImage('image/jpeg'));
        document.getElementById('export-svg').addEventListener('click', () => exportImage('image/svg+xml'));

        document.getElementById('btn-import').addEventListener('click', () => document.getElementById('file-input').click());
        document.getElementById('file-input').addEventListener('change', (e) => {
            const f = e.target.files[0]; if (!f) return;
            const r = new FileReader(); r.onload = (ev) => { try { const d = JSON.parse(ev.target.result); state.nodes = d.nodes; state.edges = d.edges; state.selection = []; saveState(); render(); } catch (err) { alert('読み込みエラー'); } };
            r.readAsText(f);
        });

        window.addEventListener('DOMContentLoaded', () => {
            try {
                const s = localStorage.getItem(STORAGE_KEY);
                if (s) { state.history.push(s); state.historyIndex = 0; restore(s); } else saveState();
            } catch (e) { console.error('Storage Error', e); saveState(); }
            render();
        });
    </script>
</body>

</html>
